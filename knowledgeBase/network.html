<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>🐅计算机网络 | 前端知识库@敲代码的小提琴手</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="logo.jpg">
    <meta name="description" content="前端er的面试必备知识——前端算法与前端面试题！">
    
    <link rel="preload" href="/frontend-knowledge-base/assets/css/0.styles.1e7c64ec.css" as="style"><link rel="preload" href="/frontend-knowledge-base/assets/js/app.fcf437a8.js" as="script"><link rel="preload" href="/frontend-knowledge-base/assets/js/3.ceeb50c6.js" as="script"><link rel="preload" href="/frontend-knowledge-base/assets/js/1.8451d83f.js" as="script"><link rel="preload" href="/frontend-knowledge-base/assets/js/21.694a1dd3.js" as="script"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/10.c53ecfbf.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/11.719e2e4d.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/12.6791d3d2.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/13.d93f6042.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/14.7704fd11.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/15.79bbd93a.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/16.c4c8517c.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/17.bb85eb87.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/18.8d2fd8ae.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/19.39fed223.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/20.c6713908.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/22.7c275bab.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/23.9e124323.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/24.a21b072d.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/25.db0ab649.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/26.ccc2a5ff.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/27.708abdd3.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/4.71c43d04.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/5.93f6240a.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/6.f3f5344e.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/7.76416851.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/8.d0d15fbd.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/9.a4cfbc82.js">
    <link rel="stylesheet" href="/frontend-knowledge-base/assets/css/0.styles.1e7c64ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1aefc0b4><div data-v-1aefc0b4><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1aefc0b4 data-v-1aefc0b4><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>前端知识库@敲代码的小提琴手</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>前端er的面试必备知识——前端算法与前端面试题！</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-1aefc0b4><header class="navbar" data-v-1aefc0b4><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/frontend-knowledge-base/" class="home-link router-link-active"><!----> <span class="site-name">前端知识库@敲代码的小提琴手</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/frontend-knowledge-base/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      more about @敲代码的小提琴手
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myGithub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/18064101621133" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myJuejin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu/frontend-knowledge-base" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  thisRepo
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1aefc0b4></div> <aside class="sidebar" data-v-1aefc0b4><div class="personal-info-wrapper" data-v-39576ba9 data-v-1aefc0b4><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>16</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/frontend-knowledge-base/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      more about @敲代码的小提琴手
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myGithub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/18064101621133" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myJuejin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu/frontend-knowledge-base" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  thisRepo
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/" class="sidebar-heading clickable router-link-active"><span>Hey!This is 敲代码的小提琴手!</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/" aria-current="page" class="sidebar-link">欢迎来到我的前端知识库！😄</a></li><li><a href="/frontend-knowledge-base/study-way/myStudyProcess.html" class="sidebar-link">我的前端学习之路🤔</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/knowledgeBase/start" class="sidebar-heading clickable open"><span>前端知识库</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/knowledgeBase/layout.html" class="sidebar-link">🐴前端基础-layout</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/JavaScript.html" class="sidebar-link">🦄前端基础-JavaScript</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/network.html" aria-current="page" class="active sidebar-link">🐅计算机网络</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/browser.html" class="sidebar-link">🐬浏览器</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/react.html" class="sidebar-link">🐧React</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/coding.html" class="sidebar-link">🐲手写代码问题(造~轮~子~)</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/optimize.html" class="sidebar-link">🐕‍🦺性能优化问题</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/experience.html" class="sidebar-link">🐪工作经验汇总</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/interview.html" class="sidebar-link">🐜面试经验</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/handbook/start" class="sidebar-heading clickable"><span>前端er必会的数据结构与算法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/handbook/struct.html" class="sidebar-link">前端必会数据结构</a></li><li><a href="/frontend-knowledge-base/handbook/algorithm.html" class="sidebar-link">前端必会算法技巧</a></li><li><a href="/frontend-knowledge-base/handbook/leetcode.html" class="sidebar-link">推荐刷题内容</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/study-everyday/study-everyday" class="sidebar-heading clickable"><span>前端校招er必会的前端知识点</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/study-everyday/22-1-study.html" class="sidebar-link">22年第一季度的每日一题</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-1aefc0b4><main class="page"><section><div class="page-title"><h1 class="title">🐅计算机网络</h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="🐅计算机网络"><a href="#🐅计算机网络" class="header-anchor">#</a> 🐅计算机网络</h1> <h2 id="计网知识体系"><a href="#计网知识体系" class="header-anchor">#</a> 计网知识体系</h2> <ul><li>HTTP协议
<ul><li>报文头部字段</li> <li>（响应报文头部的）状态码</li> <li>缓存问题
<ul><li>强缓存</li> <li>协商缓存</li></ul></li></ul></li> <li>HTTPS协议
<ul><li>对称加密、非对称加密的概念</li> <li>数字证书的用途</li> <li>SSH密钥在非对称加密中的作用、</li> <li>中间人攻击</li></ul></li> <li>TCP协议
<ul><li>三次握手</li> <li>四次挥手</li></ul></li> <li>IP协议</li> <li>跨域问题
<ul><li>相关报文头部字段</li></ul></li></ul> <h2 id="计网学习资源"><a href="#计网学习资源" class="header-anchor">#</a> 计网学习资源</h2> <blockquote><p>推荐的一些超棒的资源！</p> <ul><li><p><a href="https://mp.weixin.qq.com/s/W94ZUxGQHGDqBwIXHHD6jA" target="_blank" rel="noopener noreferrer">进阶必备的网络基础<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>小林Coding的<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxODAzNDg4NQ==&amp;action=getalbum&amp;album_id=1337204681134751744&amp;scene=173&amp;from_msgid=2247483971&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect" target="_blank" rel="noopener noreferrer">《图解网络》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://827652549.github.io/my-book/#/network/http" target="_blank" rel="noopener noreferrer">前端面试精粹<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://github.com/biaochenxuying/blog/blob/master/interview/fe-interview.md#%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener noreferrer">前端硬核面试专题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://github.com/biaochenxuying/blog/blob/master/interview/fe-interview.md#10-https" target="_blank" rel="noopener noreferrer">HTTP篇<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（作者这里笔误写成HTTPS了 其实讲的都是HTTP中的内容）</p></li> <li><p>《图解HTTP》</p></li> <li><p>《网络是如何连接的》</p></li> <li><p><a href="https://cloud.tencent.com/developer/section/1189849" target="_blank" rel="noopener noreferrer">HTTP - 指南：基础 | Guides: Basics - Basics of HTTP - 开发者手册 - 云+社区 - 腾讯云（有RFC文档翻版本）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://zhuanlan.zhihu.com/p/252251279?msclkid=05375077ab7111eca44b355c3e03ecc3" target="_blank" rel="noopener noreferrer">超高频面试题（简短易懂）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul></blockquote> <blockquote><p>计网应知应会</p> <ul><li><p>7层网络协议</p></li> <li><p>HTTP协议是重点</p> <ul><li>DNS解析</li></ul></li> <li><p>传输层相关（TCP、UDP）</p></li> <li><p>网络层相关（IP地址、IPV4、IPV6、子网掩码）</p></li></ul></blockquote> <h2 id="网络模型一览"><a href="#网络模型一览" class="header-anchor">#</a> 网络模型一览</h2> <blockquote><p>工欲善其事，必先利其器。学习计算机网络之前，让我们先对其有个大致的了解</p> <p>《图解网络》</p></blockquote> <p>主要掌握的内容为TCP/IP网络模型</p> <p>OSI参考模型做一个了解即可~</p> <p><img src="https://raw.githubusercontent.com/FangzhouSu/blog-image/main/202204152227665.png" alt="image-20210801231826185"></p> <blockquote><p>为了使得多种设备可以通过网络相互通信</p> <p>为了解决各种设备在网络互联中的兼容性问题</p> <p>国际标准化组织制定了 <strong>开放式系统互联通信参考模型</strong> 也就是OSI网络模型</p> <p>这七层的OSI模型 每层负责的职能不同~</p> <ul><li>应用层 负责给应用程序提供统一的接口</li> <li>表示层 负责把数据转换成兼容另一个系统能识别的格式</li> <li>会话层 负责建立、管理、终止 表示层实体之间的通信对话</li> <li><strong>传输层</strong> 负责端到端的数据传输</li> <li><strong>网络层</strong> 负责数据的路由、转发、分片</li> <li>数据链路层 负责数据的封帧和差错检测 以及MAC寻址</li> <li>物理层 负责在物理网络中传输数据帧</li></ul> <blockquote><p>由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并<strong>没有提供具体的实现⽅案</strong>。</p> <p>事实上，我们⽐较常⻅，也⽐较实⽤的是四层模型，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。</p></blockquote></blockquote> <p>这个经典的TCP/IP模型共有4层 我们需要熟练掌握——</p> <ul><li><p>应用层</p> <ul><li>HTTP HTTPS——推荐<code>小林Coding</code>的这篇文章~<a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A" target="_blank" rel="noopener noreferrer">硬核！30 张图解 HTTP 常见的面试题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>传输层</p> <ul><li>TCP</li> <li>UDP</li></ul></li> <li><p>网络层</p> <ul><li>IPV4</li> <li>简单了解IPV6</li></ul></li></ul> <p>我们只需要简单了解——</p> <ul><li>网络接口层（数据链路层和物理层）</li></ul> <blockquote><p>下面对于<u>网络模型总览</u>的内容来自小林Coding的《图解网络》（个人进行了一些细节上的理解+重点的标注）</p></blockquote> <p>对于同⼀台设备上的进程间通信，有很多种⽅式，⽐如有管道、消息队列、共享内存、信号等⽅式，⽽对于不同设备上的进程间通信，就需要网络通信，⽽设备是多样性的，所以要兼容多种多样的设备，就<strong>协商出了⼀套通用的网络协议</strong>（《趣谈网络协议》作者形象地称其为“打破世界的通天塔（阻碍各国进行交流的一个桎梏）的网络协议”）</p> <p>这个网络协议是分层的，<strong>每⼀层都有各自的作用和职责</strong>，接下来就分别对每⼀层进⾏介绍。</p> <h4 id="【1】应用层-application-layer"><a href="#【1】应用层-application-layer" class="header-anchor">#</a> 【1】应用层（Application Layer）</h4> <ul><li><p>是最上层的，也是我们能直接接触到那层</p></li> <li><p>我们电脑或⼿机使⽤的应⽤软件都是在应⽤层实现的</p></li> <li><p>当两个不同设备的应⽤<strong>需要通信的时候，应用就把应用数据传给下⼀层，也就是传输层</strong></p></li> <li><p>所以，应⽤层只需要<strong>专注于为用户提供应用功能，不用去关心数据是如何传输的</strong>，就类似于，我们寄快递的时候， 只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的</p></li> <li><p>⽽且应⽤层是⼯作在操作系统中的<strong>用户态</strong>，传输层及以下的⼯作在<strong>内核态</strong></p></li></ul> <h4 id="【2】传输层-transport-layer"><a href="#【2】传输层-transport-layer" class="header-anchor">#</a> 【2】传输层（Transport Layer）</h4> <ul><li><p><strong>应用层的数据包会传给传输层</strong></p></li> <li><p>传输层是<strong>为应用层提供网络支持</strong>的</p></li></ul> <p><img src="https://raw.githubusercontent.com/FangzhouSu/blog-image/main/202204152227350.png" alt="image-20210803163840067"></p> <ul><li>传输层会有两个传输协议 分别是——
<ul><li>TCP</li> <li>UDP</li></ul></li></ul> <blockquote><p>那么TCP UDP有什么区别呢😏😏😏<img src="https://pic3.zhimg.com/80/v2-b32ce00dca8c40f83212f6a256e04e6e_720w.jpg" alt="img"></p> <p>最主要的区别就是——TCP更可靠！但也同时<strong>损失了实时性</strong>，<strong>传输效率低</strong>了一些~</p></blockquote> <ul><li><p>TCP的全称叫传输层控制协议（Transmission Control Protocol），⼤部分应⽤使⽤的正是 TCP 传输层协议</p> <ul><li>比如 HTTP 应⽤层协议使用的就是TCP传输层协议</li> <li>TCP 相<strong>⽐ UDP 多了很多特性</strong>，⽐如流量控制、超时重传、拥塞控制等 这些都是为了保证数据包能<strong>可靠</strong>地传输给对方</li></ul></li> <li><p>UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对⽅</p> <ul><li>但它实时性相对TCP更好，传输效率 也⾼</li> <li>当然，UDP <strong>也可以实现可靠传输</strong>，把 TCP 的特性在应⽤层上实现就可以</li> <li>不过要实现⼀个商⽤的可靠 UDP 传输协议，也不是⼀件简单的事情</li></ul></li> <li><p>应⽤需要传输的数据可能会⾮常⼤，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最⼤报⽂段⻓度） ，就要将数据包<strong>分块</strong>（传输层蛮重要的一个特性~），这样即使中途有⼀个分块丢失或损坏了，只需要᯿新这⼀个分块，⽽不⽤重新发送整个数据包。</p></li> <li><p>在 TCP 协议中，我们把每个分块称为⼀个 TCP 段（TCP Segment）</p></li></ul> <p><img src="https://raw.githubusercontent.com/FangzhouSu/blog-image/main/202204152227178.png" alt="image-20210803164412807"></p> <ul><li><p>当设备作为接收方时，传输层则要负责<strong>把数据包传给应用</strong>，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号<strong>将应用区分开来</strong>，这个编号就是端口</p> <ul><li>比如 80 端⼝通常是 Web 服务器⽤的</li> <li>22 端⼝通常是远程登录服务器⽤的</li></ul></li> <li><p>⽽对于浏览器（客户端）中的每个标签栏都是⼀个独⽴的进程，<strong>操作系统会为这些进程分配临时的端⼝号</strong></p></li> <li><p>由于传输层的报⽂中会携带端⼝号，因此接收⽅可以识别出该报⽂是发送给哪个应⽤</p></li></ul> <h4 id="【3】网络层-internet-layer"><a href="#【3】网络层-internet-layer" class="header-anchor">#</a> 【3】网络层（Internet Layer）</h4> <blockquote><p>寻址 与 路由</p> <p>IP 协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路径</p> <ul><li><strong>寻址更像在导航，路由更像在操作方向盘</strong></li></ul></blockquote> <ul><li>可能⼤家刚接触<strong>传输层</strong>的时候，会认为它负责将数据从⼀个设备传输到另⼀个设备，事实上它<strong>并不负责</strong> <ul><li>这是网络层的活儿！！</li></ul></li></ul> <blockquote><p>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路⼝，如果⼀个设备的数据要传输给另⼀个设备，就需要<strong>在各种各样的路径和节点进⾏选择</strong>，⽽传输层的设计理念是简单、⾼效、专注，如果传输层还负责这⼀块功能就有点违背设计原则了</p></blockquote> <ul><li>也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应⽤即可，让其作为应⽤间数据传输的媒介，帮助实现应⽤到应⽤的通信，⽽<strong>实际的传输功能就交给</strong>下⼀层，也就是<strong>网络层</strong>（Internet Layer）</li></ul> <p><img src="https://raw.githubusercontent.com/FangzhouSu/blog-image/main/202204152232255.png" alt="image-20210803173110016"></p> <ul><li>网络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装 成 IP 报⽂</li> <li>如果 IP 报⽂大小超过 MTU（以太网中⼀般为 1500 字节）就会==再次进⾏分⽚==，得到⼀个即将发送到网络的 IP 报⽂</li></ul> <p><img src="https://raw.githubusercontent.com/FangzhouSu/blog-image/main/202204152232461.png" alt="image-20210803173154786"></p> <ul><li><p>网络层负责将数据从⼀个设备传输到另⼀个设备，世界上那么多设备，⼜该如何找到对⽅呢？因此，网络层需要有 区分设备的编号</p></li> <li><p>我们⼀般⽤ IP 地址给设备进⾏编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段，每段是 8 位。只有⼀个单纯 的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道⼀个⼀个去匹配？这显然不科学。 因此，需要将 IP 地址分成两种意义</p> <ul><li>⼀个是==网络号==，负责标识该 IP 地址是属于哪个⼦网的</li> <li>⼀个是==主机号==，负责标识同⼀⼦网下的不同主机</li></ul></li> <li><p>怎么分的呢？这需要<strong>配合子网掩码才能算出 IP 地址 的网络号和主机号</strong>。那么在寻址的过程中，先匹配到相同的网络号，才会去找对应的主机</p></li> <li><p>除了<strong>寻址</strong>能力， IP 协议还有另⼀个重要的能力就是<strong>路由</strong></p> <p>实际场景中，两台设备并不是⽤⼀条网线连接起来的， ⽽是通过很多网关、路由器、交换机等众多网络设备连接起来的</p> <p>那么就会形成很多条网络的路径，因此<strong>当数据包 到达⼀个网络节点，就需要通过算法决定下⼀步⾛哪条路径</strong></p></li> <li><p>所以，IP 协议的==寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛==，==路由则是根据「下⼀个⽬的地」选择路径==</p> <ul><li><strong>寻址更像在导航，路由更像在操作方向盘</strong></li></ul></li></ul> <h4 id="【4】数据链路层"><a href="#【4】数据链路层" class="header-anchor">#</a> 【4】数据链路层</h4> <ul><li><p>实际场景中，网络并不是⼀个整体，⽐如你家和我家就不属于⼀个网络，所以数据不仅可以在同⼀个网络中设备间进行传输，也可以跨网络进⾏传输</p></li> <li><p>⼀旦数据需要跨网络传输，就需要有⼀个设备同时在两个网络当中，这个设备⼀般是路由器，<strong>路由器可以通过路由表计算出下⼀个要去的 IP 地址</strong></p></li> <li><p>那问题来了，路由器怎么知道这个 IP 地址是哪个设备的呢？</p> <ul><li>于是，就需要有⼀个专⻔的层来<strong>标识网络中的设备</strong>，让数据在⼀个链路中传输，这就是<strong>数据链路层</strong>（Data Link Layer），它主要<strong>为网络层提供链路级别传输的服务</strong></li></ul> <p><img src="https://raw.githubusercontent.com/FangzhouSu/blog-image/main/202204152232173.png" alt="image-20210803174006669"></p></li> <li><p>每⼀台设备的网卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议<strong>找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了</strong></p></li></ul> <h4 id="【5】物理层"><a href="#【5】物理层" class="header-anchor">#</a> 【5】物理层</h4> <p>当数据准备要从设备发送到网络时，需要<strong>把数据包转换成电信号，让其可以在物理介质中传输</strong>，这⼀层就是物理层 （Physical Layer），它<strong>主要是为数据链路层提供⼆进制传输的服务</strong></p> <p><img src="https://raw.githubusercontent.com/FangzhouSu/blog-image/main/202204152232542.png" alt="image-20210803174144375"></p> <h4 id="【6】tcp-ip网络模型小结"><a href="#【6】tcp-ip网络模型小结" class="header-anchor">#</a> 【6】TCP/IP网络模型小结</h4> <p>综上所述，网络协议通常是由上到下，分成 5 层没，分别是应⽤层，传输层，网络层，数据链路层和物理层</p> <p>一句话概括下这几个层</p> <ul><li><p>应用层 <strong>专注于为⽤户提供应⽤功能，不⽤去关⼼数据是如何传输的。</strong></p></li> <li><p>传输层 <strong>应用层的数据包会传给传输层 也就是说 传输层是为应用层提供网络支持的。</strong></p></li> <li><p>网络层 <strong>负责将数据从⼀个设备传输到另⼀个设备</strong></p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111171141510.png" alt="image-20210803174554613"></p></li> <li><p>数据链路层 <strong>为网络层提供链路级别传输的服务</strong></p></li> <li><p>物理层 <strong>把数据包转换成电信号，让其可以在物理介质中传输</strong></p></li></ul> <p>完整的关系如下</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111171141769.png" alt="image-20210803174629200"></p> <blockquote><p>这里没有听懂也木有关系啦~</p> <p>经典面试题“输入网址到网页显示 期间发生了什么？”会从一个网络包的心路历程开始说起，带我们了解这几个层是如何分工协作将数据包从客户端/服务端送到服务端/客户端的！</p> <p>这部分内容我们在下面的“计算机网络宏观概念”中会提到！</p></blockquote> <h2 id="http相关"><a href="#http相关" class="header-anchor">#</a> HTTP相关</h2> <h3 id="_4g切换为wifi的过程中发生了什么"><a href="#_4g切换为wifi的过程中发生了什么" class="header-anchor">#</a> 4G切换为WIFI的过程中发生了什么？</h3> <blockquote><p>来自 小林Coding 的图解网络</p></blockquote> <ul><li>4G切<code>wifi</code> <ul><li>基于TCP传输协议的HTTP1 HTTP2
<ul><li>TCP协议通过四元组确定一条TCP连接 切<code>wifi</code>时 源<code>ip</code>地址会变化 需要先断开TCP连接——卡！
<ul><li>源IP 源端口 目的IP 目的端口</li></ul></li></ul></li> <li>基于QUIC+UDP传输协议的HTTP3.0
<ul><li>QUIC协议通过<strong>连接ID</strong>来标记通信的两个端点（客户端、服务端） 即使切<code>wifi</code> 也不会发生TCP重连（发生了 <strong>连接迁移</strong>）</li></ul></li> <li><img src="https://raw.githubusercontent.com/FangzhouSu/blog-image/main/UQ_50%60TK%7BGZH%7DR2WT%24%7BIPXR.jpg" alt="img"></li></ul></li></ul> <h3 id="http报文首部"><a href="#http报文首部" class="header-anchor">#</a> HTTP报文首部</h3> <blockquote><p>更多具体细节可以读一下《图解HTTP》！讲得可详细了~</p></blockquote> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111101027457.png" alt="image-20211110102718109"></p> <h5 id="通用首部字段"><a href="#通用首部字段" class="header-anchor">#</a> 通用首部字段</h5> <p>通用首部字段是指，请求报文和响应报文双方<strong>都会使用的首部</strong>。</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111101127702.png" alt="image-20211110112720637"></p> <h5 id="请求首部字段"><a href="#请求首部字段" class="header-anchor">#</a> 请求首部字段</h5> <p>请求首部字段是从客户端往服务器端<strong>发送请求报文中所使用的字段</strong>， 用于<strong>补充</strong>请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111101127565.png" alt="image-20211110112742415"></p> <h5 id="响应首部字段"><a href="#响应首部字段" class="header-anchor">#</a> 响应首部字段</h5> <p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段， 用于<strong>补充</strong>响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111101127907.png" alt="image-20211110112751761"></p> <h5 id="实体首部字段"><a href="#实体首部字段" class="header-anchor">#</a> 实体首部字段</h5> <p>实体首部字段是包含在请求报文和响应报文中的<strong>实体部分所使用的首部</strong>，用于<strong>补充</strong>内容的更新时间等与实体相关的信息。</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111101127448.png" alt="image-20211110112758301"></p> <h5 id="为cookie服务的首部字段"><a href="#为cookie服务的首部字段" class="header-anchor">#</a> 为Cookie服务的首部字段</h5> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111101130537.png" alt="image-20211110113059259"></p> <p>两个很重要的首部字段！！</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111101131098.png" alt="image-20211110113114974"></p> <p>简单解析</p> <ul><li>服务器发给客户端的报文中携带的Set-Cookie字段</li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111101131989.png" alt="image-20211110113140853"></p> <ul><li>客户端发给服务端的报文中携带的Cookie字段</li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111101132222.png" alt="image-20211110113242041"></p> <h3 id="http1优化-强缓存-协商缓存"><a href="#http1优化-强缓存-协商缓存" class="header-anchor">#</a> http1优化——强缓存&amp;协商缓存</h3> <blockquote><p>《图解网络》</p> <p><a href="https://juejin.cn/book/6844733750048210957/section/6844733750106931214" target="_blank" rel="noopener noreferrer">前端性能优化原理与实践 - 修言 - 掘金课程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <blockquote><p>强缓存策略和协商缓存策略</p> <blockquote><p>字节二面原题orz 当时听都没听说过</p> <p>”啊？强缓存 对应的是弱缓存么？😫“  ”对应的是协商缓存😑😑“</p></blockquote> <ul><li><p>在缓存命中时<strong>都会直接使用本地的缓存副本</strong>；</p></li> <li><p>它们缓存不命中时，都会<strong>向服务器发送请求来获取资源</strong>。在实际的缓存机制中，强缓存策略和协商缓存策略是一起<strong>合作使用</strong>的。</p> <ul><li><strong>浏览器</strong>首先会根据请求的信息判断<strong>强缓存</strong>是否命中，【1】如果命中则直接使用本地资源的副本。如果不命中则【2】根据头信息向服务器发起请求，使用协商缓存——</li> <li>【3】如果<strong>协商缓存</strong>命中的话（资源没有过期，服务器响应报文状态码为304 临时重定向），则<strong>服务器</strong>不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则服务器返回最新的资源给浏览器。</li></ul></li></ul></blockquote> <h4 id="缓存技术实现"><a href="#缓存技术实现" class="header-anchor">#</a> 缓存技术实现</h4> <blockquote><p>对于一些具有重复性的HTTP请求 比如<strong>每次请求得到的数据都是一样的</strong> 我们就可以把这对<strong>请求-响应</strong>的数据都缓存在本地 那么下次就直接读取本地的数据 不必再通过网络获取服务器的响应了~</p></blockquote> <p>这样的话HTTP/1.1的性能肯定可以获得肉眼可见的提升！</p> <p>总结一下上面所说的 避免发送HTTP请求的方法 就是通过==缓存技术==来实现 HTTP设计者早在之前就考虑到了这点 因此<strong>HTTP协议的头部有不少是针对缓存的字段</strong></p> <h4 id="缓存技术实现细节"><a href="#缓存技术实现细节" class="header-anchor">#</a> 缓存技术实现细节</h4> <p>再来刨根问底一下 缓存是如何做到的呢？</p> <blockquote><p>【1】客户端会把<strong>第一次请求以及相应的数据保存在本地磁盘上</strong></p> <p>其中将请求的URL作为key 而响应作为value 两者形成映射关系 <strong>URL-&gt;响应</strong></p> <p>这样 当后续发起相同的请求时 就可以先在本地磁盘上通过key查到对应的value 也就是响应 （前提：资源没有过期）<img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201150051848.png" alt="image-20210810095837315"></p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201150051236.png" alt="image-20210810095923121"></p></blockquote> <h4 id="更新缓存的资源"><a href="#更新缓存的资源" class="header-anchor">#</a> 更新缓存的资源</h4> <p>看到这里 新的问题又会出现了——</p> <p>万一<strong>缓存的响应不是最新的</strong>，而客户端并不知情 那么该怎么办呢？</p> <p>这个问题HTTP的设计者也早已考虑到了~</p> <blockquote><p>服务器在发送HTTP响应时 会<strong>估算一个过期的时间</strong> 并把这个信息放到响应头部中——</p> <p>这样客户端在<strong>查看响应头部的信息时，【2】一旦发现缓存的响应是过期的，则就会重新发送网络请求</strong>。（强缓存命中则直接使用本地资源的副本。如果不命中则根据头信息向服务器发起请求，使用协商缓存，也就是接下来的【3】）</p></blockquote> <p>HTTP关于缓存说明的头部字段很多~这部分内容之后再仔细研究下 暂时不再拓展了</p> <h4 id="更新缓存资源细节"><a href="#更新缓存资源细节" class="header-anchor">#</a> 更新缓存资源细节</h4> <p>最后再来思考一个问题——</p> <blockquote><p>如果客户端从第⼀次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有 变更，还是⽼样⼦，那么你觉得还要在服务器的响应带上这个资源吗？</p> <p>很显然不带的话，可以提⾼ HTTP 协议的性能，那具体如何做到呢？</p></blockquote> <p>是啊 如果在重新发送请求的时候发现资源并没有变更 那么服务器在响应的时候应该返回什么资源呢？</p> <blockquote><p>【3】这个就需要我们在客户端重新发送请求时 <strong>在请求的 <code>Etag</code> 头部带上第一次请求的响应头部中的摘要</strong>，这个<u>摘要是唯一标识响应的资源</u>，当服务器收到请求后 会将本地资源的摘要（也就是最新的摘要） 与 请求中的摘要（缓存中的摘要）做个比较——</p> <ul><li>如果不同 说明客户端的缓存（URL-&gt;响应）已经没有价值 服务器将在响应中带上最新的资源。</li></ul> <p><img src="D:%5CAA_Web_Front-end_Development%5C%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5C%E8%AE%A1%E7%BD%91%5C%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0.assets%5Cimage-20210810101411121.png" alt="image-20210810101411121"></p> <ul><li>如果相同 说明客户端的缓存还是可以继续使用的 那么服务器<strong>仅返回不含有包体的 <code>304 Not Modified</code> 响应</strong> 来告诉客户端“缓存的资源仍然有效哦！” 这样可以减少响应资源在网络中传输的延时！
<ul><li>==协商缓存==</li></ul></li></ul> <p><img src="D:%5CAA_Web_Front-end_Development%5C%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5C%E8%AE%A1%E7%BD%91%5C%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0.assets%5Cimage-20210810101704953.png" alt="image-20210810101704953"></p></blockquote> <p>通过本个问题 - “如何避免发送HTTP请求” 对4个小点的研究</p> <p>我们发现每一个点都包含了“缓存”</p> <p>可以看出来 缓存真的是性能优化的一把万能钥匙！</p> <p>小到 CPU Cache、Page Cache、Redis Cache</p> <p>大到HTTP协议的缓存~</p> <h3 id="队头阻塞问题-http1-1-2-3"><a href="#队头阻塞问题-http1-1-2-3" class="header-anchor">#</a> 队头阻塞问题-HTTP1.1/2/3</h3> <blockquote><p>【1】HTTP1.1的问题在于管道化 http请求都是在pipeline里进行传输 虽然可以将多条请求放入请求队列 但是服务器响应时只会响应一个请求</p> <p>【2】HTTP2的问题主要是因为TCP重传这个机制</p> <p>【3】所以想改善HTTP2的TCP队头阻塞问题，只能换网络协议——换成UDP 就ok了——HTTP3的内容</p></blockquote> <ul><li>【1】HTTP 1.1的队头阻塞问题 —— ==HTTP队头阻塞==
<ul><li>存在问题——HTTP管道化</li></ul></li></ul> <p><strong>HTTP管道化</strong>（在响应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了 <strong>要求FIFO</strong>）要求服务端必须<strong>按照请求发送的顺序返回响应</strong>，那如果一个响应返回延迟了，那么其后续的响应都会被延迟（如下图）</p> <blockquote><p>HTTP/1.1 中的管道（ pipeline）传输中<strong>如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了</strong>  —— 《图解网络》</p></blockquote> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202112141218170.png" alt="image-20211214121811091"></p> <ul><li>HTTP2通过多路复用解决1.1中的队头阻塞问题 —— ==TCP队头阻塞==
<ul><li>存在问题——如果丢包会触发TCP<strong>重传</strong>机制，所有http请求都要等着那个丢包被<strong>重传</strong>回来</li></ul></li></ul> <p><strong>移除了 HTTP/1.1 中的请求</strong>，服务端不需要按照FIFO的顺序返回响应，而是可以并发地返回响应！</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202112141214162.png" alt="image-20211214121440057"></p> <p>但是这种情况可能产生TCP队头阻塞</p> <blockquote><p>HTTP/2 <strong>多个HTTP请求复⽤⼀个TCP连接</strong>，⼀旦==发⽣丢包==，就会触发TCP的重传机制，<strong>阻塞住所有的 HTTP 请求</strong>。这样在⼀个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。  ——《图解网络》</p></blockquote> <ul><li>HTTP3把 HTTP 下层的 TCP 协议改成了 <strong>UDP</strong></li></ul> <p>UDP 发⽣是<strong>不管顺序，也不管丢包的</strong>，所以不会出现 HTTP/1.1 的==队头阻塞== 和 HTTP/2 的==⼀个丢包全部重传问题==</p> <h3 id="http-超文本传输协-基础概念"><a href="#http-超文本传输协-基础概念" class="header-anchor">#</a> HTTP-超文本传输协-基础概念</h3> <blockquote><p>《图解网络》</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>“聊聊<span class="token constant">HTTP</span>
	<span class="token constant">HTTP</span>是啥嘞
    详细解释下“超文本传输协议呗”
    <span class="token constant">HTTP</span>是只用于服务器传客户端嘛？
    <span class="token constant">HTTP</span>常见的状态码 说几个
    <span class="token constant">HTTP</span>常见的字段 说几个”
</code></pre></div><h4 id="_1-http是啥"><a href="#_1-http是啥" class="header-anchor">#</a> 1.HTTP是啥？</h4> <p><strong>超文本传输协议</strong></p> <p><code>HyperText Transfer Protocol</code></p> <ul><li><p>HTTP基于TCP/IP 是关于数据如何在万维网中通信的协议</p></li> <li><p><strong>HTTP的底层是TCP/IP</strong></p></li> <li><p>用于传送 WWW 方式的数据</p></li></ul> <h4 id="_2-详细解释-超文本传输协议"><a href="#_2-详细解释-超文本传输协议" class="header-anchor">#</a> 2.详细解释“超文本传输协议”</h4> <p>分三部分来看——</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlU4cfNS4t8C0AjG8YleW3FjITV4h4aQNn1iboHhjALOGicsFsLuQAXwVaQ/640?wx_fmt=png" alt="img"></p> <p>（很基础了！）</p> <ul><li>协议</li></ul> <p><strong>协</strong> 要求由两个以上的参与者</p> <p><strong>议</strong> 产生对参与者的一种<strong>行为约定和规范</strong></p> <p>对于用在计算机世界中的HTTP协议</p> <p>它使用计算机能够理解的语言确立了一种</p> <p>【1】计算机之间交流通信的规范（”协“）</p> <p>【2】交流通信相关的各种 控制&amp;错误处理 方式（”议“）</p> <ul><li>传输</li></ul> <p>注意 HTTP协议是一个 <strong>双向协议</strong></p> <p>双向协议：客户端可以发送请求到服务端 服务端也可以把请求数据发送到客户端</p> <p>同时 也要注意 —— 数据在我们看来是在两点之间传递 但是允许中间由中转/接力</p> <blockquote><p>举个例子 第一排的同学传递小纸条到后排同学时 需要经过好多同学</p></blockquote> <p>在HTTP中 中间人只要遵循 HTTP协议 并在不打扰基本数据传输的前提下 就可以添加额外的内容</p> <p>到这里 可以给HTTP协议下一个更加贴切的定义了（加上”两点之间双向传输“这个概念）</p> <blockquote><p>HTTP协议是一个在计算机世界中专门用来在==两点之间传输数据==的约定和规范</p></blockquote> <ul><li>超文本</li></ul> <p><strong>超越了普通文本的文本</strong> 文字、图片、视频、超链接的混合体</p> <p>HTML就是常见的超文本 可以通过超链接实现跳转 另外 是一个有文字、有画面视频的丰富的网页</p> <ul><li>小结 超文本传输协议 确切一些的定义</li></ul> <p>记住几个点——”协议——约定和规范“ ”传输——在两点之间“ ”超文本——传输的内容（文字、图片、音视频“</p> <p><strong>超文本传输协议</strong>是</p> <blockquote><p>一个在计算机世界里==专门在**「两点」<strong>之间</strong>「传输」<strong>文字、图片、音视频等</strong>「超文本」<strong>数据的</strong>「约定和规范」**==</p></blockquote> <h4 id="_3-http只能用于-服务端与客户端之间-传输超文本-正确嘛"><a href="#_3-http只能用于-服务端与客户端之间-传输超文本-正确嘛" class="header-anchor">#</a> 3.HTTP只能用于 服务端与客户端之间 传输超文本？正确嘛？</h4> <ul><li>不正确</li> <li>还可以用于 <strong>从服务器传输超文本数据到服务器</strong></li></ul> <blockquote><p>所以 HTTP协议 的描述 要这么说——”采用==两点之间==传输超文本“</p></blockquote> <h4 id="_4-http常见的状态码"><a href="#_4-http常见的状态码" class="header-anchor">#</a> 4.HTTP常见的状态码</h4> <p>这里就顺着说就行了——（举一些常见的例子）</p> <ul><li>成功的报文</li> <li>重定向的报文
<ul><li>请求资源没了 301</li> <li>请求资源还有  但是要换个URL 302</li></ul></li> <li>客户端错误
<ul><li>服务器禁止访问 403 Forbidden</li> <li>服务器上不存在 / 没找到 404 Not Found</li></ul></li> <li>服务器错误
<ul><li>访问后端服务器发生错误 502 Bad Gateway</li> <li>服务器正忙 暂时无法响应 503 Service Unavailable</li></ul></li></ul> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUfV6qkzg4yHtOibAfTv6hTicOx73F55WWl4nW2FWlXnDJ7Igd9kvrrRnA/640?wx_fmt=png" alt="img"></p> <p>先说说总览</p> <ul><li>1xx 提示信息</li></ul> <p>协议处理中的一种中间状态 很少用</p> <ul><li>2xx 成功处理请求
<ul><li>「<strong>200 OK</strong>」 最常见的成功状态码 一切正常！</li> <li>「<strong>204 No Content</strong>」  也是很常见的成功状态码 （区别：响应头没有body数据）</li> <li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断电续传。</li></ul></li></ul> <p>表示**==服务器==成功处理了<strong>客户端的</strong>请求**</p> <ul><li>3xx 重定向请求
<ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了</li> <li>「<strong>302 Moved Temporarily</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li> <li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</li></ul></li></ul> <p>表示客户端请求的==资源==发生了==变动==，<strong>需要客户端用新的 URL 重新发送请求获取资源</strong>，也就是<strong>重定向</strong>。</p> <ul><li>4xx 客户端错误
<ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个<strong>笼统的错误</strong>。
<ul><li>「<strong>403 Forbidden</strong>」表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li> <li>「<strong>404 Not Found</strong>」表示请求的资源<strong>在服务器上不存在或未找到</strong>，所以无法提供给客户端。</li></ul></li></ul></li></ul> <p>表示==客户端==发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p> <ul><li>5xx 服务器错误
<ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
<ul><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li> <li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li> <li>「<strong>503 Service Unavailable</strong>」表示服务器当前<strong>很忙，暂时无法响应服务器</strong>，类似“网络服务正忙，请稍后重试”的意思。</li></ul></li></ul></li></ul> <p>表示客户端请求报文正确，但是**==服务器处理时==内部==发生了错误==**，属于服务器端的错误码。</p> <h4 id="_5-http常见字段"><a href="#_5-http常见字段" class="header-anchor">#</a> 5.HTTP常见字段</h4> <p>==常见字段这里还需要多看些文章学习下！==</p> <p>HTTP包从应用层被发出（自带HTTP头部） 经过传输层、网络层、链路层之后会加上</p> <p>TCP头部 IP头部 MAC头部</p> <p>这些头部中的字段帮助数据包抵达服务端~</p> <p>HTTP协议的头域包括 <code>通用头，请求头，响应头和实体头</code> 四个部分。</p> <ul><li>每个头域由一个域名，冒号（:）和域值三部分组成。</li></ul> <p>【1】Host</p> <p>客户端发送请求时 用来指定服务器的域名</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlU6aoJZ8ROGvuttxDGXYnKXgzDdOBXibKpZVoqhkArdZ3QvMBBDaLONkw/640?wx_fmt=jpeg" alt="img"></p> <p>通过Host字段 将请求发往<strong>同一台服务器上的不同网站</strong></p> <p>【2】Content-Length</p> <p>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlU79Ir1qmS5DMj7XLLibaibsbUEUN5JyB2ugmEHcxwIe7JBkBHM99XQp3g/640?wx_fmt=jpeg" alt="img"></p> <p>【3】Connection</p> <p>最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUlhrVicZt4iaLPPibcD8KQV4z9vqwAaAjdtkjUo5fGlKOsTaicbtEDO4u1Q/640?wx_fmt=jpeg" alt="image"></p> <p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p> <p>一个==可以复用的 TCP 连接就这样建立了，直到客户端或服务器主动关闭连接==。</p> <p>但是，这不是标准字段（是因为用于兼顾老版本么？这里说得不很清楚）。</p> <p>【4】Content-Type</p> <p>用于服务器回应时，告诉客户端，本次数据是什么格式。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUPPfeuboYtO6sBBQw5JI76dSrAoNlvjs2TysKiaPyVGHrtjFJiblIhfNQ/640?wx_fmt=jpeg" alt="img"></p> <p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p> <p>这里在html后缀文件中经常看到~</p> <p>【5】Content-Encoding</p> <p>说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUn83Xqku5tIB6zNdHsnFH08xfURlVHdtGQiaYfF21ib3koxICwrwRnckg/640?wx_fmt=jpeg" alt="img"></p> <p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p> <p>同时 客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以<strong>接受哪些压缩方法</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>Accept-Encoding: gzip, deflate
</code></pre></div><h3 id="来聊聊get-post"><a href="#来聊聊get-post" class="header-anchor">#</a> 来聊聊GET POST</h3> <blockquote><p>图解网络</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>“来聊聊<span class="token constant">GET</span> <span class="token constant">POST</span>
	<span class="token constant">GET</span> <span class="token constant">POST</span> 的区别
    这俩方法都是安全和幂等的嘛？”
</code></pre></div><h4 id="_1-get-post的区别-edition1"><a href="#_1-get-post的区别-edition1" class="header-anchor">#</a> 1.GET POST的区别-edition1</h4> <blockquote><p>《图解网络》</p></blockquote> <p>简单来说</p> <ul><li><p>一个是发请求给服务器来要资源（GET）</p></li> <li><p>一个是发请求给服务器来给服务器提交数据（POST）</p></li></ul> <p>与POST恰好相反 一个是索取 一个是给予~</p> <p>具体来说一下</p> <ul><li>Get ⽅法的含义是请求从服务器获取资源。这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。</li></ul> <blockquote><p>⽐如，你打开浏览器上的一篇文章，浏览器就会发送 GET 请求给服务器，服务器就会返回⽂章的所有⽂字及资源</p></blockquote> <p><img src="https://img-blog.csdnimg.cn/9b009d37f2f546c6a956b63ea09bbd6d.png" alt="请添加图片描述"></p> <ul><li><p>⽽ POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。</p> <blockquote><p>URI，统一资源标志符(Uniform Resource Identifier， URI)</p> <p><em>URL</em>一般指统一资源定位系统（uniform resource locator;<em>URL</em>）</p> <p>表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行标识的</p></blockquote> <blockquote><p>⽐如，你在小林的公众号中的⽂章底部敲⼊了留⾔后点击「提交」，浏览器就会执⾏⼀次 POST 请求，把你的 留⾔⽂字放进了报⽂ body ⾥，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器</p></blockquote></li></ul> <p><img src="https://img-blog.csdnimg.cn/645caf7a0bdb435284b6177916807ae0.png" alt="请添加图片描述"></p> <h4 id="_1-get-post的区别-edition2"><a href="#_1-get-post的区别-edition2" class="header-anchor">#</a> 1.GET POST的区别-edition2</h4> <blockquote><p>更详尽的内容</p></blockquote> <p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p> <ul><li><strong>应用场景：<strong>GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说</strong>请求一个网页的资源</strong>。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如<strong>注册用户，提交信息这一类</strong>的操作。</li> <li>**是否缓存：**因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li> <li>**发送的报文格式：**Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li> <li>**安全性：**Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li> <li>**请求长度：**浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li> <li>**参数类型：**post 的参数传递支持更多的数据类型。</li></ul> <h4 id="_2-这俩方法都是安全和幂等的嘛"><a href="#_2-这俩方法都是安全和幂等的嘛" class="header-anchor">#</a> 2.这俩方法都是安全和幂等的嘛？</h4> <blockquote><p>先说明下安全和幂等的概念：</p> <ul><li>在 HTTP 协议⾥，所谓的「安全」是指请求⽅法<strong>不会「破坏」服务器上的资源</strong>。</li> <li>所谓的「幂等」，意思是<strong>多次执行相同的操作，结果都是「相同」的</strong>。（和执行一次一样）</li></ul></blockquote> <p>根据上面对两个方法的了解——</p> <ul><li><p>很明显 GET ⽅法就是安全且==幂等==的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是==<strong>安全</strong>==的，且每次的结果都是<strong>相同</strong>的</p></li> <li><p>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是==不安全的==，且多次提交数据就会创建多个资源，所以==不是幂等的==</p></li></ul> <h2 id="https相关"><a href="#https相关" class="header-anchor">#</a> HTTPS相关</h2> <blockquote><p>《图解HTTP》</p> <h4 id="浏览器灵魂之问-第9篇-https为什么让数据传输更安全"><a href="#浏览器灵魂之问-第9篇-https为什么让数据传输更安全" class="header-anchor">#</a> <a href="https://juejin.cn/post/6844904021308735502#heading-84" target="_blank" rel="noopener noreferrer">浏览器灵魂之问 第9篇:HTTPS为什么让数据传输更安全？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4></blockquote> <h3 id="对称加密-非对称加密"><a href="#对称加密-非对称加密" class="header-anchor">#</a> 对称加密 &amp; 非对称加密</h3> <ul><li>对称加密（也叫共享密钥加密）
<ul><li>不安全！</li> <li>处理速度较快</li></ul></li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111111238602.png" alt="image-20211111123822391"></p> <ul><li><p>非对称加密（也叫公开密钥加密）</p> <ul><li>更加安全（缺点是公开密钥可能被替换，所以使用下面提到的数字证书）</li> <li>处理速度较慢</li></ul> <blockquote><p>非对称加密~（下面那里写错了哈哈）</p></blockquote></li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111111238559.png" alt="image-20211111123856422"></p> <h3 id="https的混合加密机制"><a href="#https的混合加密机制" class="header-anchor">#</a> HTTPS的混合加密机制</h3> <p>对称加密+非对称加密</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111111235564.png" alt="image-20211111123546328"></p> <h3 id="可以证明公开密钥正确性的证书-数字证书"><a href="#可以证明公开密钥正确性的证书-数字证书" class="header-anchor">#</a> 可以证明公开密钥正确性的证书-数字证书</h3> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111111234902.png" alt="image-20211111123455666"></p> <h3 id="https的通信机制"><a href="#https的通信机制" class="header-anchor">#</a> HTTPS的通信机制</h3> <blockquote><p>有点长啊这个！图解HTTP中一共是给出了12步~</p></blockquote> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111111244776.png" alt="image-20211111124406509"></p> <p>下面的内容当作一个了解吧~实际应用中/题目中遇到了再来看看</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111111243609.png" alt="image-20211111124320356"></p> <h3 id="ssh在git中的作用"><a href="#ssh在git中的作用" class="header-anchor">#</a> SSH在git中的作用</h3> <p>SSH是一种协议标准,其目的是实现<strong>安全远程登录</strong>以及其它<strong>安全网络服务</strong>.</p> <blockquote><p><code>SSH(Secure Shell)</code>仅仅是一个<strong>协议标准</strong> ,其具体的实现有很多,既有开源实现的OpenSSH,也有商业实现方案.使用范围最广泛的当然是开源实现OpenSSH.</p></blockquote> <p>如何实现数据的安全呢？首先想到的实现方案肯定是对数据进行加密.加密的方式主要有两种:</p> <ol><li>对称加密（也称为秘钥加密）</li> <li>非对称加密（也称公钥加密）</li></ol> <p>非对称加密</p> <p><img src="https://upload-images.jianshu.io/upload_images/9818632-8b02afc463f47a89.jpg" alt="img"></p> <p>1.远程Server收到Client端用户TopGun的登录请求，<strong>Server把自己的公钥发给用户.</strong></p> <p>2.Client使用这个公钥,将密码进行加密.</p> <p>3.Client将加密的密码发送给Server端.</p> <p>4.远程Server用自己的私钥,解密登录密码,然后验证其合法性.</p> <p>5.若验证结果正确,给Client相应的响应.</p> <p>可能出现的安全问题，中间人攻击——</p> <blockquote><p>Client端不能保证接受到的公钥就是目标Server端的,如果一个攻击者中途拦截Client的登录请求,向其发送自己的公钥,Client端<strong>用攻击者的公钥进行数据加密</strong>.攻击者接收到加密信息后<strong>再用自己的私钥进行解密</strong>,不就窃取了Client的登录信息了吗？这就是所谓的<em>中间人攻击</em></p></blockquote> <p><img src="https://upload-images.jianshu.io/upload_images/9818632-0c6da2b6e1346e7f.jpg" alt="img"></p> <p>SSH的作用 在非对称加密中 （帮助客户端）<strong>对服务端的公钥进行认证</strong></p> <ul><li>在https中可以通过CA来进行公证,可是SSH的publish key和private key都是自己生成的,没法公证.只能通过Client端自己对公钥进行确认</li></ul> <p>SSH基于公钥进行认证的方式——</p> <p><img src="https://upload-images.jianshu.io/upload_images/9818632-53cf70110d87cfbc.jpg" alt="img"></p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201200956946.png" alt="image-20220120095656824"></p> <p>作者：shuaiutopia
链接：https://www.jianshu.com/p/cab7e436a7aa
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> <blockquote><p>下面是面试过程中遇到比较典型的一个问题~</p></blockquote> <h3 id="【面试】https的一个传输过程"><a href="#【面试】https的一个传输过程" class="header-anchor">#</a> 【面试】HTTPS的一个传输过程</h3> <blockquote><p>21年十一月字节一面时问到的内容</p></blockquote> <ul><li>非对称加密建立HTTPS连接</li> <li>然后使用对称加密进行报文的收发</li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111111235564.png" alt="image-20211111123546328"></p> <h5 id="追问-说一下非对称加密是如何利用公钥私钥解决安全问题的-之前第一问里有挖坑"><a href="#追问-说一下非对称加密是如何利用公钥私钥解决安全问题的-之前第一问里有挖坑" class="header-anchor">#</a> 追问-说一下非对称加密是如何利用公钥私钥解决安全问题的（之前第一问里有挖坑）</h5> <p>当时答得有点乱，下来整理了一下，感觉清晰不少~</p> <blockquote><p>另外搜索非对称算法时，网上好多文章没说的一点就是这个非对称算法是用来干啥的，根据图解HTTP的内容，我的理解是以下几个步骤：</p> <ul><li>【1】客户端有私钥A + 公钥A； 服务器有私钥B + 公钥B</li> <li>【2】规则——私钥A+公钥A = 密钥对A（公钥A加密的内容只有私钥A可以解密！）</li> <li>【3】为了建立安全的通信道路（不被坏人篡改、冒名顶替（窃听就木有办法辣，不过也不怕！我们这个是非对称加密！被窃听了也不会被破解的）），客户端把手里的公钥发送给服务器</li> <li>【4】服务器使用拿到的公钥A进行<strong>重要报文</strong>（也就是图解HTTP提到的 “<strong>稍后的共享密钥加密中要使用的密钥</strong>”）的加密，之后再发给客户端</li> <li>【5】客户端手里有私钥A，直接解密这个<strong>重要报文</strong>，安全地获得共享密钥！妙啊！</li></ul> <p>这样互联网上的不法分子就没辙辣！</p> <blockquote><p>另外还可以使用数字证书解决公开密钥的传输问题 - 图解HTTP很香啊！</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111111234902.png" alt="image-20211111123455666"></p></blockquote></blockquote> <h2 id="我们访问一个网页的大致过程-前后端交互过程"><a href="#我们访问一个网页的大致过程-前后端交互过程" class="header-anchor">#</a> 我们访问一个网页的大致过程 前后端交互过程</h2> <blockquote><p>这个问题是从cookie 的 domain字段的内容引起的！</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111082005281.png" alt="image-20211108200508226"></p> <p>很奇怪这个domain中的“域名”到底是前端服务器的域名还是后端服务器的域名呢？</p> <p>为啥前端服务器还要个域名呢？</p> <p>搜素了资料，进行学习</p></blockquote> <ul><li>前后端交互的过程——
<ul><li>cookie生成的时间点</li></ul></li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111082001427.png" alt="image-20211108200124299"></p> <ul><li>拓展下跨域的问题</li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111082001136.png" alt="image-20211108200133079"></p> <h2 id="输入网址到网页显示-期间发生了什么"><a href="#输入网址到网页显示-期间发生了什么" class="header-anchor">#</a> 输入网址到网页显示 期间发生了什么？</h2> <blockquote><p>这个超级全面的考察问题，能挖多深就挖多深！</p> <p><a href="https://juejin.cn/post/6844904021308735502#heading-24" target="_blank" rel="noopener noreferrer">浏览器灵魂之问 第3篇: 说一说从输入URL到页面呈现发生了什么？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844904021308735502#heading-33" target="_blank" rel="noopener noreferrer">浏览器灵魂之问 第4篇: 说一说从输入URL到页面呈现发生了什么？——解析算法篇<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844904021308735502#heading-46" target="_blank" rel="noopener noreferrer">浏览器灵魂之问 第5篇: 说一说从输入URL到页面呈现发生了什么？——渲染过程篇<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="跨域cors问题"><a href="#跨域cors问题" class="header-anchor">#</a> <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener noreferrer">跨域CORS问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>？</h2> <h3 id="浏览器并不是拒绝所有的跨域请求-实际上拒绝的是跨域的读操作"><a href="#浏览器并不是拒绝所有的跨域请求-实际上拒绝的是跨域的读操作" class="header-anchor">#</a> 浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作</h3> <p>严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的：
通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向；
通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签；
通常浏览器不允许跨域读操作（Cross-origin reads）。</p> <blockquote><p>有个学弟问这块儿来着 找来阮大的文章读读学习一下</p> <p>另外 MDN对<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noopener noreferrer">跨域资源共享CORS的解释<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>CORS是一个W3C标准，全称是**&quot;跨域资源共享&quot;（Cross-origin resource sharing）**。</p> <p>它允许浏览器向跨源服务器，发出<a href="https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener noreferrer"><code>XMLHttpRequest</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>请求，从而克服了AJAX只能<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener noreferrer">同源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>使用的限制。</p> <p>本文详细介绍CORS的内部机制。</p> <p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p> <p>浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求（确定是否同源的请求），但用户不会有感觉。</p> <p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p> <h3 id="简单请求、非简单请求"><a href="#简单请求、非简单请求" class="header-anchor">#</a> 简单请求、非简单请求</h3> <p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p> <p>只要同时满足以下两大条件，就属于简单请求。</p> <blockquote><p>（1) 请求方法是以下三种方法之一：</p> <ul><li>HEAD</li> <li>GET</li> <li>POST</li></ul> <p>（2）HTTP的头信息不超出以下几种字段：</p> <ul><li>Accept</li> <li>Accept-Language</li> <li>Content-Language</li> <li>Last-Event-ID</li> <li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></blockquote> <p>凡是不同时满足上面两个条件，就属于非简单请求。</p> <h4 id="简单请求的流程"><a href="#简单请求的流程" class="header-anchor">#</a> 简单请求的流程</h4> <p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p> <p>下面是一个例子，浏览器发现这次<strong>跨源AJAX请求是简单请求</strong>，就自动在头信息之中，添加一个<code>Origin</code>字段。</p> <blockquote><div class="language-http extra-class"><pre class="language-http"><code><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/cors</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Origin</span><span class="token punctuation">:</span> <span class="token header-value">http://api.bob.com</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">api.alice.com</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Language</span><span class="token punctuation">:</span> <span class="token header-value">en-US</span></span>
<span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">keep-alive</span></span>
<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">Mozilla/5.0...</span></span>
</code></pre></div></blockquote> <p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p> <p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息<strong>没有包含</strong><code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p> <p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段，如下的123行</p> <blockquote><div class="language-js extra-class"><pre class="language-js"><code>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> <span class="token string">'http://api.bob.com'</span> 
<span class="token comment">// 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span> 
<span class="token comment">// 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Expose<span class="token operator">-</span>Headers<span class="token operator">:</span> FooBar  如果想拿到其他字段，就必须在这里面指定
<span class="token comment">// 上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> 
charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">;</span>
</code></pre></div></blockquote> <p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p> <h3 id="解决跨域的几种方式"><a href="#解决跨域的几种方式" class="header-anchor">#</a> 解决跨域的几种方式</h3> <ul><li><p>JSONP 使用script标签向后台请求数据，只适用于get请求</p></li> <li><p>CORS是让服务器端设置Access-Control-Allow-Origin（头部字段），这样浏览器就不会报跨域错误</p></li> <li><p>反向代理，搭建一个自己的服务器，让自己的服务器请求数据，拿到数据之后再返回给我自己</p></li></ul> <h2 id="cookie-session"><a href="#cookie-session" class="header-anchor">#</a> Cookie&amp;Session</h2> <blockquote><p><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener noreferrer">COOKIE和SESSION有什么区别？ - 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <blockquote><ul><li><p>Session是在服务端保存的一个数据结构，用来<strong>跟踪用户的状态</strong>，这个数据可以保存在集群、数据库、文件中；</p> <ul><li>用户验证这种场合一般会用 session</li></ul></li> <li><p>Cookie是客户端保存用户信息的一种机制，用来<strong>记录用户的一些信息</strong>，也是<strong>实现Session的一种方式</strong>。</p> <ul><li>session id 是存在 cookie 中</li></ul></li></ul></blockquote> <h1 id="操作系统"><a href="#操作系统" class="header-anchor">#</a> 操作系统</h1> <blockquote><p>简单的操作系统学习资料</p> <p>前端er也要掌握的操作系统知识！https://zhuanlan.zhihu.com/p/268219780?msclkid=23e52f55ab7111ec98d5b55925f4d474</p></blockquote></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/frontend-knowledge-base/knowledgeBase/JavaScript.html" class="prev">
            🦄前端基础-JavaScript
          </a></span> <span class="next"><a href="/frontend-knowledge-base/knowledgeBase/browser.html">
            🐬浏览器
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#计网知识体系" class="sidebar-link reco-side-计网知识体系" data-v-cb1513f6>计网知识体系</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#计网学习资源" class="sidebar-link reco-side-计网学习资源" data-v-cb1513f6>计网学习资源</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#网络模型一览" class="sidebar-link reco-side-网络模型一览" data-v-cb1513f6>网络模型一览</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#http相关" class="sidebar-link reco-side-http相关" data-v-cb1513f6>HTTP相关</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#_4g切换为wifi的过程中发生了什么" class="sidebar-link reco-side-_4g切换为wifi的过程中发生了什么" data-v-cb1513f6>4G切换为WIFI的过程中发生了什么？</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#http报文首部" class="sidebar-link reco-side-http报文首部" data-v-cb1513f6>HTTP报文首部</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#http1优化-强缓存-协商缓存" class="sidebar-link reco-side-http1优化-强缓存-协商缓存" data-v-cb1513f6>http1优化——强缓存&amp;协商缓存</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#队头阻塞问题-http1-1-2-3" class="sidebar-link reco-side-队头阻塞问题-http1-1-2-3" data-v-cb1513f6>队头阻塞问题-HTTP1.1/2/3</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#http-超文本传输协-基础概念" class="sidebar-link reco-side-http-超文本传输协-基础概念" data-v-cb1513f6>HTTP-超文本传输协-基础概念</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#来聊聊get-post" class="sidebar-link reco-side-来聊聊get-post" data-v-cb1513f6>来聊聊GET POST</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#https相关" class="sidebar-link reco-side-https相关" data-v-cb1513f6>HTTPS相关</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#对称加密-非对称加密" class="sidebar-link reco-side-对称加密-非对称加密" data-v-cb1513f6>对称加密 &amp; 非对称加密</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#https的混合加密机制" class="sidebar-link reco-side-https的混合加密机制" data-v-cb1513f6>HTTPS的混合加密机制</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#可以证明公开密钥正确性的证书-数字证书" class="sidebar-link reco-side-可以证明公开密钥正确性的证书-数字证书" data-v-cb1513f6>可以证明公开密钥正确性的证书-数字证书</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#https的通信机制" class="sidebar-link reco-side-https的通信机制" data-v-cb1513f6>HTTPS的通信机制</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#ssh在git中的作用" class="sidebar-link reco-side-ssh在git中的作用" data-v-cb1513f6>SSH在git中的作用</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#【面试】https的一个传输过程" class="sidebar-link reco-side-【面试】https的一个传输过程" data-v-cb1513f6>【面试】HTTPS的一个传输过程</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#我们访问一个网页的大致过程-前后端交互过程" class="sidebar-link reco-side-我们访问一个网页的大致过程-前后端交互过程" data-v-cb1513f6>我们访问一个网页的大致过程 前后端交互过程</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#输入网址到网页显示-期间发生了什么" class="sidebar-link reco-side-输入网址到网页显示-期间发生了什么" data-v-cb1513f6>输入网址到网页显示 期间发生了什么？</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#跨域cors问题" class="sidebar-link reco-side-跨域cors问题" data-v-cb1513f6>跨域CORS问题？</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#浏览器并不是拒绝所有的跨域请求-实际上拒绝的是跨域的读操作" class="sidebar-link reco-side-浏览器并不是拒绝所有的跨域请求-实际上拒绝的是跨域的读操作" data-v-cb1513f6>浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#简单请求、非简单请求" class="sidebar-link reco-side-简单请求、非简单请求" data-v-cb1513f6>简单请求、非简单请求</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#解决跨域的几种方式" class="sidebar-link reco-side-解决跨域的几种方式" data-v-cb1513f6>解决跨域的几种方式</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/knowledgeBase/network.html#cookie-session" class="sidebar-link reco-side-cookie-session" data-v-cb1513f6>Cookie&amp;Session</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/frontend-knowledge-base/assets/js/app.fcf437a8.js" defer></script><script src="/frontend-knowledge-base/assets/js/3.ceeb50c6.js" defer></script><script src="/frontend-knowledge-base/assets/js/1.8451d83f.js" defer></script><script src="/frontend-knowledge-base/assets/js/21.694a1dd3.js" defer></script>
  </body>
</html>
