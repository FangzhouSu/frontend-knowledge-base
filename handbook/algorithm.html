<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>👨‍💻解题技巧与必会算法 | 前端知识库@敲代码的小提琴手</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="logo.jpg">
    <meta name="description" content="前端er的面试必备知识——前端算法与前端面试题！">
    
    <link rel="preload" href="/frontend-knowledge-base/assets/css/0.styles.1e7c64ec.css" as="style"><link rel="preload" href="/frontend-knowledge-base/assets/js/app.fcf437a8.js" as="script"><link rel="preload" href="/frontend-knowledge-base/assets/js/3.ceeb50c6.js" as="script"><link rel="preload" href="/frontend-knowledge-base/assets/js/1.8451d83f.js" as="script"><link rel="preload" href="/frontend-knowledge-base/assets/js/11.719e2e4d.js" as="script"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/10.c53ecfbf.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/12.6791d3d2.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/13.d93f6042.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/14.7704fd11.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/15.79bbd93a.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/16.c4c8517c.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/17.bb85eb87.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/18.8d2fd8ae.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/19.39fed223.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/20.c6713908.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/21.694a1dd3.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/22.7c275bab.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/23.9e124323.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/24.a21b072d.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/25.db0ab649.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/26.ccc2a5ff.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/27.708abdd3.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/4.71c43d04.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/5.93f6240a.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/6.f3f5344e.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/7.76416851.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/8.d0d15fbd.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/9.a4cfbc82.js">
    <link rel="stylesheet" href="/frontend-knowledge-base/assets/css/0.styles.1e7c64ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1aefc0b4><div data-v-1aefc0b4><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1aefc0b4 data-v-1aefc0b4><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>前端知识库@敲代码的小提琴手</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>前端er的面试必备知识——前端算法与前端面试题！</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-1aefc0b4><header class="navbar" data-v-1aefc0b4><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/frontend-knowledge-base/" class="home-link router-link-active"><!----> <span class="site-name">前端知识库@敲代码的小提琴手</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/frontend-knowledge-base/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      more about @敲代码的小提琴手
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myGithub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/18064101621133" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myJuejin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu/frontend-knowledge-base" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  thisRepo
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1aefc0b4></div> <aside class="sidebar" data-v-1aefc0b4><div class="personal-info-wrapper" data-v-39576ba9 data-v-1aefc0b4><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>16</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/frontend-knowledge-base/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      more about @敲代码的小提琴手
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myGithub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/18064101621133" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myJuejin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu/frontend-knowledge-base" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  thisRepo
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/" class="sidebar-heading clickable router-link-active"><span>Hey!This is 敲代码的小提琴手!</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/" aria-current="page" class="sidebar-link">欢迎来到我的前端知识库！😄</a></li><li><a href="/frontend-knowledge-base/study-way/myStudyProcess.html" class="sidebar-link">我的前端学习之路🤔</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/knowledgeBase/start" class="sidebar-heading clickable"><span>前端知识库</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/knowledgeBase/layout.html" class="sidebar-link">🐴前端基础-layout</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/JavaScript.html" class="sidebar-link">🦄前端基础-JavaScript</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/network.html" class="sidebar-link">🐅计算机网络</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/browser.html" class="sidebar-link">🐬浏览器</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/react.html" class="sidebar-link">🐧React</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/coding.html" class="sidebar-link">🐲手写代码问题(造~轮~子~)</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/optimize.html" class="sidebar-link">🐕‍🦺性能优化问题</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/experience.html" class="sidebar-link">🐪工作经验汇总</a></li><li><a href="/frontend-knowledge-base/knowledgeBase/interview.html" class="sidebar-link">🐜面试经验</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/handbook/start" class="sidebar-heading clickable open"><span>前端er必会的数据结构与算法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/handbook/struct.html" class="sidebar-link">前端必会数据结构</a></li><li><a href="/frontend-knowledge-base/handbook/algorithm.html" aria-current="page" class="active sidebar-link">前端必会算法技巧</a></li><li><a href="/frontend-knowledge-base/handbook/leetcode.html" class="sidebar-link">推荐刷题内容</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/study-everyday/study-everyday" class="sidebar-heading clickable"><span>前端校招er必会的前端知识点</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/study-everyday/22-1-study.html" class="sidebar-link">22年第一季度的每日一题</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-1aefc0b4><main class="page"><section><div class="page-title"><h1 class="title">👨‍💻解题技巧与必会算法</h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="👨‍💻解题技巧与必会算法"><a href="#👨‍💻解题技巧与必会算法" class="header-anchor">#</a> 👨‍💻解题技巧与必会算法</h1> <h2 id="_01-双指针"><a href="#_01-双指针" class="header-anchor">#</a> 01 双指针</h2> <ul><li>同向而行快慢指针（常用于链表）</li> <li>反向而行双指针（对撞指针，常用于数组）</li></ul> <h3 id="【1】链表中的双指针"><a href="#【1】链表中的双指针" class="header-anchor">#</a> 【1】链表中的双指针</h3> <p>【medium】<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener noreferrer">19. 删除链表的倒数第 N 个结点<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>【easy】<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener noreferrer">206. 反转链表<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>【medium】<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener noreferrer">92.反转链表 II<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="【2】有序数组中的双指针-求和、比大小"><a href="#【2】有序数组中的双指针-求和、比大小" class="header-anchor">#</a> 【2】有序数组中的双指针-求和、比大小</h3> <blockquote><p>前提为：数组有序——以便双指针帮助我们缩小定位的范围。</p></blockquote> <p>【easy】<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener noreferrer">88. 合并两个有序数组<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>【medium】<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener noreferrer">15. 三数之和<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="【3】快慢指针"><a href="#【3】快慢指针" class="header-anchor">#</a> 【3】快慢指针</h3> <blockquote><p>巧妙利用快慢指针解决移动某些元素（通过交换）、删除某些元素 等问题</p></blockquote> <h4 id="_283-移动零"><a href="#_283-移动零" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener noreferrer">283. 移动零<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>nums<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      slow<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    fast<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_02-哈希表"><a href="#_02-哈希表" class="header-anchor">#</a> 02 哈希表</h2> <blockquote><p>这个真的是超级常用的技巧~ 熟练使用哈希表可以解决许多高频问题！</p> <p>在《必会数据结构》-数组&amp;字符串 部分 我多次使用哈希表进行解题</p></blockquote> <h3 id="借助map的哈希表求解"><a href="#借助map的哈希表求解" class="header-anchor">#</a> 借助Map的哈希表求解</h3> <blockquote><p>这种比较常规，正如上面提到的——必会数据结构-数组&amp;字符串 中 经常使用</p></blockquote> <h3 id="不借助map的哈希表求解"><a href="#不借助map的哈希表求解" class="header-anchor">#</a> 不借助Map的哈希表求解</h3> <blockquote><p>有些哈希表题目如果使用了Map是没有必要的 甚至会导致解不出来题目（因为Map数据结构是一个映射的关系），记录一下这些题目！</p></blockquote> <h4 id="_1189-气球-的最大数量"><a href="#_1189-气球-的最大数量" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/maximum-number-of-balloons/" target="_blank" rel="noopener noreferrer">1189. “气球” 的最大数量<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <blockquote><p>2/13的每日一题 非常棒的一题！</p></blockquote> <ul><li><code>哈希表 字符串</code> <ul><li>使用数组存储数频</li> <li>在求解有限、规律的元素时 不需要使用Map！</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxNumberOfBalloons</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> textArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'b'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      textArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      textArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'l'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      textArr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'o'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      textArr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      textArr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  textArr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>textArr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  textArr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>textArr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>textArr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// return Math.min.apply(null, textArr);</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_03-递归"><a href="#_03-递归" class="header-anchor">#</a> 03 递归</h2> <ul><li>递归的基本原理  <a href="https://juejin.cn/post/7016324095843237901" target="_blank" rel="noopener noreferrer">掌握递归调用栈思想 由浅入深研究递归🎉<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>树的前中后序遍历</li> <li>数组、链表等题目中的递归骚操作</li></ul> <h2 id="_04-dfs-bfs"><a href="#_04-dfs-bfs" class="header-anchor">#</a> 04 DFS BFS</h2> <h3 id="【1】dfs-深度优先搜索"><a href="#【1】dfs-深度优先搜索" class="header-anchor">#</a> 【1】DFS 深度优先搜索</h3> <blockquote><p>之前写的专题记录<a href="https://blog.csdn.net/qq_45704942/article/details/117712490" target="_blank" rel="noopener noreferrer">深度优先搜索 leetcode104 101 112 543 129 五道题小练一下深度优先遍历搜索算法 java刷题笔记<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <blockquote><p>一句话理解DFS：走迷宫，不撞南墙不回头，撞了南墙回到上一个节点再次去撞南墙（取决于有几个岔路口），撞遍当前节点的南墙再往回退一个节点（换个岔路口），以此类推…</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17190aa8a73ba344~tplv-t2oaga2asx-watermark.awebp" alt="img"></p> <p>本质为栈结构</p> <ul><li>搜索过程中的前进、后退操作与栈结构的入栈、出栈过程很相似！</li></ul></blockquote> <h3 id="二叉树中的dfs"><a href="#二叉树中的dfs" class="header-anchor">#</a> 二叉树中的DFS</h3> <p>还是根据上例来说，我们使用递归编程解决这个问题——<strong>递归式就是我们选择道路的过程，而递归边界就是“南墙”</strong></p> <p>在二叉树中</p> <ul><li>节点就好比是迷宫里的坐标</li> <li>图中的每个节点在作为父节点时无疑是岔路口</li> <li>空节点就是“南墙”。</li></ul> <p>比如二叉树的前序遍历就是一个策略明显（先撞左侧的南墙，撞穿勒左侧再去撞右侧，然后再回到前一个节点…）的DFS的过程——空节点就是这个问题里的“南墙”，</p> <p>也可以说 <strong>先序遍历是DFS思想的递归实现</strong>，后面我们接触的很多题都可以用DFS思想来递归实现！（不撞南墙不回头~）</p> <p>来看看代码——</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">// 边界条件——“南墙”</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
</code></pre></div><h3 id="为什么说dfs的本质是栈"><a href="#为什么说dfs的本质是栈" class="header-anchor">#</a> 为什么说DFS的本质是栈？</h3> <p>我的理解：DFS的实现与栈的原理类似（一般都用递归来快速模拟深度优先搜索的过程，而递归的原理就是“函数调用<strong>栈</strong>”）</p> <blockquote><p><a href="https://juejin.cn/book/6844733800300150797/section/6844733800358887438" target="_blank" rel="noopener noreferrer">修言大大的理解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（本知识库中好多思想都是从修言大大的这本掘金小册学来的！真的很受用！）</p> <ul><li>首先，函数调用的底层，仍然是由栈来实现的。JS 会维护一个叫“函数调用栈”的东西（类似的思想我写过一篇文章  <a href="https://juejin.cn/post/7016324095843237901" target="_blank" rel="noopener noreferrer">掌握递归调用栈思想 由浅入深研究递归🎉<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就是说这个递归调用栈的~），<code>preorder</code>每调用一次自己，相关调用的上下文就会被<code>push</code>进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被<code>pop</code>出来。因此，即便二叉树的递归调用过程中，并没有出现栈这种数据结构，也依然改变不了递归的本质是栈的事实。</li> <li>其次，DFS 作为一种思想，它和树的递归遍历一脉相承、却并不能完全地画上等号——DFS 的解题场景其实有很多，其中有一类会要求我们记录每一层递归式里路径的状态，此时就会强依赖栈结构（这一点会在下一节的真题实战中体现得淋漓尽致）。</li></ul></blockquote> <h3 id="【2】bfs广度优先搜索"><a href="#【2】bfs广度优先搜索" class="header-anchor">#</a> 【2】BFS广度优先搜索</h3> <blockquote><p>之前写的专题记录</p> <p><a href="https://blog.csdn.net/qq_45704942/article/details/117884207" target="_blank" rel="noopener noreferrer">广度优先搜索 刷熟一个模板（层序遍历打印二叉树）秒杀一堆问题leetcode102 111 116 617 java刷题笔记<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>DFS的实现与栈的原理类似</p> <p>而BFS的实现与<strong>队列</strong>密不可分，做一道贼经典的题就知道了</p> <h4 id="_102-二叉树的层序遍历"><a href="#_102-二叉树的层序遍历" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">102. 二叉树的层序遍历<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>我们要做的是对这个二叉树进行层序遍历。</p> <p><strong>层序遍历</strong>的概念很好理解：按照层次的顺序，从上到下，从左到右地遍历一个二叉树，如图所示（红色数字即为遍历的序号）：</p> <blockquote><p>欸嘿！这不就是我们的BFS广度优先搜索麽！</p></blockquote> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1719130c81086dbb~tplv-t2oaga2asx-watermark.awebp" alt="img"></p> <ul><li>效率有点低 但是好想的方法~每一层都有个辅助数组temp</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 用队列辅助进行二叉树的广度搜索</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 存这一层的节点</span>
        <span class="token keyword">let</span> currentL <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token comment">// 存当前这一层有几个节点~</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentL<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 将这一层的所有节点广度搜索一遍，并顺带着探索一下每个节点的下一层有没有节点，如果有则加入到队列中</span>
            <span class="token keyword">let</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将每一次for循环遍历得到的节点值加入临时数组temp中</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将一层的节点值加入到答案数组中</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>高效官方题解——就改了一处想法（如注释）但是效率一下子起来了！太优秀勒！</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> currentLevelSize <span class="token operator">=</span> q<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        ret<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 二维数组中添加一个一位数组来存这一层的节点值</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> currentLevelSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret<span class="token punctuation">[</span>ret<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 依次将节点值加入到队列末尾的那个数组（代表着当前层）中</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_05-回溯"><a href="#_05-回溯" class="header-anchor">#</a> 05 回溯</h2> <ul><li>回溯算法的基本思想</li></ul> <blockquote><p>从一条路往前走，能进则进，不能进则退回来，换一条路再试。——leetcode</p></blockquote> <blockquote><p>这里的“回溯”二字，可以理解为是在强调上面提到的 <code>DFS</code> 过程中“退一步重新选择”这个动作。这样想的话， <code>DFS</code> 算法其实就是回溯思想的体现。</p></blockquote> <blockquote><p>涉及剪枝操作的递归，我们一般称之为回溯。——某算法书籍</p></blockquote> <blockquote><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种<strong>走不通就退回再走的技术</strong>为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。
许多复杂的，规模较大的问题都可以使用回溯法，有“<strong>通用解题方法</strong>”的美称。——前端算法与数据结构面试</p></blockquote> <h3 id="【1】解题模板"><a href="#【1】解题模板" class="header-anchor">#</a> 【1】解题模板</h3> <h4 id="什么时候用回溯算法"><a href="#什么时候用回溯算法" class="header-anchor">#</a> 什么时候用回溯算法？</h4> <ul><li>题目中暗示了一个/多个解，要求我们列出来每一个解的 <strong>具体内容</strong></li> <li>冷静分析下，可以转化为 <strong>树形逻辑模型求解</strong></li></ul> <h4 id="为什么用回溯算法"><a href="#为什么用回溯算法" class="header-anchor">#</a> 为什么用回溯算法？</h4> <ul><li>递归与回溯的过程，本身就是 <strong>穷举</strong> 的过程
<ul><li>如果题目要求我们把每一个解都列举出来，那么自然就需要 <strong>穷举</strong></li></ul></li> <li>穷举所有可能性时，对构建出来的搜索树进行恰当的剪枝（具体过程可以看下面题目的题解）</li></ul> <blockquote><p>不让列举出解的所有情况，只问解的个数。</p> <p>用动态规划。这可是个老大难问题！</p> <ul><li>背包问题</li> <li>跑楼梯问题</li> <li>…</li></ul></blockquote> <h4 id="怎么用回溯算法"><a href="#怎么用回溯算法" class="header-anchor">#</a> 怎么用回溯算法？</h4> <ul><li>分析问题要关注<strong>一个模型</strong> <ul><li>树形逻辑模型
<ul><li>要能想出来这个模型</li> <li>要会找树形模型中的 <strong>坑位</strong> <ul><li>一个坑位对应树中的一层</li> <li>每一层的处理逻辑（递归式的内容）一般都是一样的</li></ul></li></ul></li></ul></li> <li>写代码要关注<strong>两个要点</strong>（所有递归问题都是关注这俩玩意儿）
<ul><li>递归式
<ul><li>树形逻辑模型每一层的处理逻辑即为递归式</li></ul></li> <li>递归边界
<ul><li>即为题目“每个答案的要求” / “坑位数量的边界”</li></ul></li></ul></li></ul> <p>伪代码总结下编码形式（这部分内容只是一个简单<strong>模板</strong>，具体情况还要结合题意（和根据题意分析出来的树形逻辑结构）来分析）——</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">具体问题</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">入参</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    定义辅助数组，缓存后面题目要用到的变量（数组长度啥的）
    <span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 定义路径栈——回溯思想中最重要的辅助</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 结果数组，把path中的内容加入到res中，往往使用res.push(path.slice())</span>
    <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">递归参数</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>达到递归边界<span class="token punctuation">)</span><span class="token punctuation">{</span>
       		处理边界逻辑，往往和path内容有关<span class="token operator">/</span>向结果数组res中加入内容
           	<span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// </span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>遍历“坑位”的可选值<span class="token punctuation">)</span><span class="token punctuation">{</span>
            path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>当前遍历到这个坑位的值<span class="token punctuation">)</span><span class="token punctuation">;</span>
        	处理坑位本身的相关逻辑
            path<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token function">dfs</span><span class="token punctuation">(</span>回溯起点<span class="token punctuation">)</span><span class="token punctuation">;</span>	

<span class="token punctuation">}</span>
</code></pre></div><h3 id="【2】递归回溯经典题目"><a href="#【2】递归回溯经典题目" class="header-anchor">#</a> 【2】递归回溯经典题目</h3> <h4 id="_46-全排列"><a href="#_46-全排列" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener noreferrer">46. 全排列<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p> <p>示例 1：</p> <div class="language- extra-class"><pre class="language-text"><code>输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre></div><p>回溯法解题</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21d81055e~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">permute</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存数组的长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length
  <span class="token comment">// curr 变量用来记录当前的排列内容</span>
  <span class="token keyword">const</span> curr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// res 用来记录所有的排列顺序</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// visited 用来避免重复使用同一个数字</span>
  <span class="token keyword">const</span> visited <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 定义 dfs 函数，入参是坑位的索引（从 0 计数）</span>
  <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">nth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>nth <span class="token operator">===</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 此时前 len 个坑位已经填满，将对应的排列记录下来</span>
          res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">return</span> 
      <span class="token punctuation">}</span>
      <span class="token comment">// 检查手里剩下的数字有哪些</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">// 给 nums[i] 打个“已用过”的标</span>
              visited<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
              <span class="token comment">// 将nums[i]推入当前排列</span>
              curr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
              <span class="token comment">// 基于这个排列继续往下一个坑走去</span>
              <span class="token function">dfs</span><span class="token punctuation">(</span>nth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> 
              <span class="token comment">// nums[i]让出当前坑位</span>
              curr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
              <span class="token comment">// 下掉“已用过”标识</span>
              visited<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 从索引为 0 的坑位（也就是第一个坑位）开始 dfs</span>
  <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_78-子集"><a href="#_78-子集" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener noreferrer">78. 子集<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p> <p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p> <div class="language- extra-class"><pre class="language-text"><code>输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</code></pre></div><p>回溯法解题</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a25410cf07~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 入参是一个数组</span>
<span class="token keyword">const</span> <span class="token function-variable function">subsets</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化结果数组</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   
    <span class="token comment">// 缓存数组长度</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length
    <span class="token comment">// 初始化组合数组</span>
    <span class="token keyword">const</span> subset <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 进入 dfs</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  

    <span class="token comment">// 定义 dfs 函数，入参是 nums 中的数字索引</span>
    <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 每次进入，都意味着组合内容更新了一次，故直接推入结果数组</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>subset<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 从当前数字的索引开始，遍历 nums</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>index<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这是当前数字存在于组合中的情况</span>
            subset<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> 
            <span class="token comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token comment">// 这是当前数字不存在与组合中的情况</span>
            subset<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回结果数组</span>
    <span class="token keyword">return</span> res 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_77-组合"><a href="#_77-组合" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener noreferrer">77. 组合<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p> <p>你可以按 <strong>任何顺序</strong> 返回答案。</p> <div class="language- extra-class"><pre class="language-text"><code>输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</code></pre></div><p>对搜索树进行剪枝，答案为红箭头串联起来的内容</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a254223576~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">combine</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 初始化结果数组</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   
    <span class="token comment">// 初始化组合数组</span>
    <span class="token keyword">const</span> subset <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 进入 dfs，起始数字是1</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  

    <span class="token comment">// 定义 dfs 函数，入参是当前遍历到的数字</span>
    <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>subset<span class="token punctuation">.</span>length <span class="token operator">===</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>subset<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> 
        <span class="token punctuation">}</span>
        <span class="token comment">// 从当前数字的值开始，遍历 index-n 之间的所有数字</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>index<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这是当前数字存在于组合中的情况</span>
            subset<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> 
            <span class="token comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token comment">// 这是当前数字不存在与组合中的情况</span>
            subset<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回结果数组</span>
    <span class="token keyword">return</span> res 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_06-排序问题"><a href="#_06-排序问题" class="header-anchor">#</a> 06 排序问题</h2> <ul><li>基础排序算法：
<ul><li>冒泡排序</li> <li>插入排序</li> <li>选择排序</li></ul></li> <li>进阶排序算法
<ul><li>归并排序</li> <li>快速排序</li></ul></li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202112070855512.png" alt="image-20211207085549434"></p> <blockquote><ul><li><p>一个经典问题：选择排序的时间复杂度与数组的有序性无关~其实我觉得快排也算是无关吧（跟哨兵元素的选择有关捏），但是牛客的答案给到的是选择排序</p> <p>顺带着复习了一遍选择排序的写法，双层循环，遇到更小的值则更新那一轮的最小值索引</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
  <span class="token comment">// 缓存数组长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length 
  <span class="token comment">// 定义 minIndex，缓存当前区间最小值的索引，注意是索引</span>
  <span class="token keyword">let</span> minIndex  
  <span class="token comment">// i 是当前排序区间的起点</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 初始化 minIndex 为当前区间第一个元素</span>
    minIndex <span class="token operator">=</span> i  
    <span class="token comment">// i、j分别定义当前区间的上下界，i是左边界，j是右边界</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token comment">// 若 j 处的数据项比当前最小值还要小，则更新最小值索引为 j</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        minIndex <span class="token operator">=</span> j
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果 minIndex 对应元素不是目前的头部元素，则交换两者</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>minIndex <span class="token operator">!==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div></blockquote> <h3 id="【1】简单排序"><a href="#【1】简单排序" class="header-anchor">#</a> 【1】简单排序</h3> <ul><li>冒泡排序</li> <li>插入排序</li> <li>选择排序</li></ul> <h3 id="【2】快速排序"><a href="#【2】快速排序" class="header-anchor">#</a> 【2】快速排序</h3> <p><a href="https://leetcode-cn.com/problems/sort-an-array/solution/javascriptjava-chao-xiang-xi-ti-jie-tian-dsvc/" target="_blank" rel="noopener noreferrer">JavaScript&amp;Java 超详细题解 填坑法快排~ - 排序数组 - 力扣（LeetCode） (leetcode-cn.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">sortArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用快排方法</span>
    <span class="token keyword">return</span> nums<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">quicksort</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 得到用来将数组分成两部分（左面全小于index 右面全大于index）的索引</span>
        <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 以第一轮得出的index为基准划分出左半区和右半区 对数组的左半区进行递归 将其全部变为有序</span>
        <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 同理左半区</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">partition</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 选定第一个元素为基准值 把它拿出来 即为“挖坑”</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 【1】 挖了坑就需要填坑~从high指针开始向左找 </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            high<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 一旦找到比坑对应值pivot小的 就扔到low那侧的坑里</span>

        <span class="token comment">// 【2】 同【1】从low指针开始向右找填坑值</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            low<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 一旦找到比坑对应值pivot大的 就扔到high那侧的坑里</span>
        <span class="token comment">//（刚刚这侧有一个值去填low那侧的坑了 所以出现了一个坑位~）</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 经过上面【1】【2】的不断迭代 low===high 此时这个位置即为基准位置</span>
    arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>
    <span class="token keyword">return</span> low<span class="token punctuation">;</span> <span class="token comment">// 分区成功！返回定海神针~（此时low=high哦~）</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_07-动态规划"><a href="#_07-动态规划" class="header-anchor">#</a> 07 动态规划</h2> <blockquote><p>前端er如果了解dp的话肯定是大大滴加分项咯！比较常见的dp问题包括——</p> <p>斐波那契数列、背包问题、爬楼梯问题、打家劫舍问题等，这些建议掌握嗷！</p> <p>建议掌握的预备知识：递归——了解递归调用栈的一个原理，理解起来会更加轻松~</p></blockquote> <blockquote><p>22/1/24更——动归不是洪水猛兽，一步步来理解，没那么难！</p></blockquote> <h3 id="【1】轻松入门动态规划"><a href="#【1】轻松入门动态规划" class="header-anchor">#</a> 【1】轻松入门动态规划</h3> <h4 id="入门-斐波那契数列"><a href="#入门-斐波那契数列" class="header-anchor">#</a> 入门-斐波那契数列</h4> <blockquote><p><a href="https://blog.csdn.net/zjxxyz123/article/details/80147546" target="_blank" rel="noopener noreferrer">递归，记忆化搜索与动态规划_Keep Learning-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>——感谢这篇很简单易懂的文章，帮我理解了<code>记忆化搜索+递归=(约等于)动态规划</code></p> <ul><li><strong>记忆化搜索和递归</strong>大致思路一样，是一种<strong>自顶向下</strong>的思路</li> <li><strong>动态规划</strong>则是一种<strong>自底向上</strong>的思路</li></ul></blockquote> <ul><li><code>超简单的递归</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">fb</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">fb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>递归树如下，可以看到存在大量重复计算
<img src="https://img-blog.csdn.net/2018043009544876?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqeHh5ejEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p> <ul><li><code>记忆化搜索</code>提升效率</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> <span class="token function-variable function">fb</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 这一步就是记忆化搜素新添的内容，使用一个数组来保存子问题的答案——这也正是动态规划的思想</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>简单的动归解法</code> <ul><li>将原问题拆解成若干个子问题，同时<strong>保存子问题的答案</strong>——使得每个子问题只求解一次，最终获得原问题的答案~</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">fib</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// console.log(dp);</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>和上面的斐波那契数列异曲同工~</p> <p>很easy！</p></blockquote> <h4 id="_70-爬楼梯"><a href="#_70-爬楼梯" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">70. 爬楼梯<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <ul><li><p><strong>记忆化递归</strong></p> <blockquote><p>理解记忆化递归 为自己的面试加分！</p> <ul><li>使用数组存储中间结果；</li> <li>中间结果如果存在，则不要重复使用递归式进行计算！</li></ul></blockquote> <p>由于递归太耗时，可以用记忆化递归避免重复的计算。
<strong>解题过程：</strong>
1.先对n为0这种特殊情况进行处理，然后n为1和2时直接return即可
2.memo数组：存储中间结果，避免重复计算
3.接下来就是判断memo[n]是否存在，如果计算过即存在，直接返回，无需重复计算；若不存在，则进行递归计算，为前两个之和。
<strong>代码</strong></p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n
    
    <span class="token comment">// 记忆化递归 避免重复计算</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>经典动归问题</p> <p>分成多个子问题，爬第n阶楼梯的<strong>方法</strong>数量，等于 2 部分之和</p> <p>​	<strong>爬上 n-1 阶楼梯的方法数量</strong></p> <p>​	<strong>爬上 n-2 阶楼梯的方法数量</strong></p> <div class="language- extra-class"><pre class="language-text"><code>动态规划的转移方程为：dp[i] = dp[i - 1] + dp[i - 2];
</code></pre></div><p>简单地使用动归求解（这里没必要使用递归这种时间复杂度较高的方法，除非用了记忆化递归~）</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>时间复杂度与空间复杂度都为O(N)</p> <ul><li>使用滚动数组（<strong>空间复杂度为1</strong>）实现动态规划（而不是使用<strong>空间复杂度为N</strong>的递归）
<ul><li>这也是官方题解的第一种方法（其他数学方法我退缩了XD）
<ul><li><img src="https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif" alt="fig1"></li></ul></li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 初始化dp[0] dp[1] dp[2]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 利用滚动数组达到O(1)空间复杂度的动归</span>
    p <span class="token operator">=</span> q<span class="token punctuation">;</span>
    q <span class="token operator">=</span> r<span class="token punctuation">;</span>
    r <span class="token operator">=</span> p <span class="token operator">+</span> q<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="【2】使用动态规划解决复杂问题"><a href="#【2】使用动态规划解决复杂问题" class="header-anchor">#</a> 【2】使用动态规划解决复杂问题</h3> <h4 id="_53-最大子序和"><a href="#_53-最大子序和" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener noreferrer">53. 最大子序和<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>很好的一篇题解，把思想说得蛮清楚</p> <p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/" target="_blank" rel="noopener noreferrer">经典动态规划问题（理解「无后效性」）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_08-前缀和"><a href="#_08-前缀和" class="header-anchor">#</a> 08 前缀和</h2> <h2 id="_09-位运算"><a href="#_09-位运算" class="header-anchor">#</a> 09 位运算</h2> <h3 id="【1】位运算基础知识"><a href="#【1】位运算基础知识" class="header-anchor">#</a> 【1】位运算基础知识</h3> <h4 id="按位与-a-b"><a href="#按位与-a-b" class="header-anchor">#</a> 按位<strong>与</strong> a &amp; b</h4> <p>【1】a b转换为二进制【2】进行按位运算 “且”的规则</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0</span><span class="token operator">&amp;</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token number">0</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">1</span><span class="token operator">&amp;</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token number">1</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>利用这个特性可以快速判断一个数字是否为奇数（最后一个二进制是否为1）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// true</span>
<span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// false</span>
</code></pre></div><h4 id="按位或-a-b"><a href="#按位或-a-b" class="header-anchor">#</a> 按位<strong>或</strong> a | b</h4> <p>【1】a b转换为二进制【2】进行按位运算  “或”的规则</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">0</span><span class="token operator">|</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token number">1</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="异或-a-b"><a href="#异或-a-b" class="header-anchor">#</a> <strong>异或</strong>  a ^ b</h4> <p>很有用的运算符!! 【1】a b转换为二进制【2】进行按位运算  “相同的数异或得0 任何数与0异或等于本身”的规则</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 二进制</span>
<span class="token number">0</span><span class="token operator">^</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">0</span> <span class="token number">1</span><span class="token operator">^</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token number">0</span><span class="token operator">^</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span> <span class="token number">1</span><span class="token operator">^</span><span class="token number">0</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token comment">// 十进制</span>
<span class="token number">6</span> <span class="token operator">^</span> <span class="token number">6</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token number">0</span> <span class="token operator">^</span> <span class="token number">666</span> <span class="token operator">=</span> <span class="token number">666</span>
</code></pre></div><ul><li><p>两个经典用法</p> <ul><li><p>找出没有重复得数（一组数，都是成对的，只有一个落单的）进行全部异或运算最终结果即为落单那个数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">4</span><span class="token operator">^</span><span class="token number">5</span><span class="token operator">^</span><span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">4</span> <span class="token operator">=</span> （<span class="token number">1</span><span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">^</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">5</span><span class="token operator">=</span> <span class="token number">0</span><span class="token operator">^</span><span class="token number">0</span><span class="token operator">^</span><span class="token number">0</span><span class="token operator">^</span><span class="token number">0</span><span class="token operator">^</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token comment">// 异或支持交换律和结合律~</span>
</code></pre></div></li> <li><p>不使用额外得辅助变量 交换两个数x y的位置</p> <div class="language-js extra-class"><pre class="language-js"><code>x <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span>
y <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span>
x <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <h4 id="短路运算符-逻辑与-a-b"><a href="#短路运算符-逻辑与-a-b" class="header-anchor">#</a> 短路运算符 逻辑与 a &amp;&amp; b</h4> <ul><li><p>a 和 b都为真 才返回true</p></li> <li><p>进行位运算时</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token number">6</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 发生短路（有一个结果为假）</span>
<span class="token number">6</span> <span class="token operator">&amp;&amp;</span> <span class="token number">8</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token number">8</span> <span class="token operator">&amp;&amp;</span> <span class="token number">6</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token number">6</span> <span class="token operator">&amp;&amp;</span> <span class="token number">7</span> <span class="token operator">&amp;&amp;</span> <span class="token number">8</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">// 两个都为true才不会发生短路 返回最后一个值</span>
</code></pre></div><ul><li>优先级比||高</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">3</span> <span class="token operator">||</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token number">5</span> <span class="token operator">||</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">3</span>
<span class="token comment">// 先计算 2&amp;&amp;5=5 然后计算 3||5=3 最后得到 3||0=3 </span>
</code></pre></div><h4 id="短路运算符-逻辑或-a-b"><a href="#短路运算符-逻辑或-a-b" class="header-anchor">#</a> 短路运算符 逻辑或 a || b</h4> <ul><li>a与b有一个为真 返回true</li> <li>进行位运算时</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0</span> <span class="token operator">||</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 结果为假时，返回第二个为假的值0</span>
<span class="token number">6</span> <span class="token operator">||</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token operator">||</span> <span class="token number">6</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// 结果为真时，返回第一个为真的值 </span>
<span class="token number">6</span> <span class="token operator">||</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">// 因为是短路，所以前面出现一个true，不看后面直接停止</span>
</code></pre></div><ul><li>项目开发时，经常对一个数据进行逻辑或运算避免其报错 <code>let obj = xxx || {}</code></li></ul> <h3 id="【2】位运算经典应用"><a href="#【2】位运算经典应用" class="header-anchor">#</a> 【2】位运算经典应用</h3> <h4 id="找出排序数组中只出现一次的数字-延伸题目"><a href="#找出排序数组中只出现一次的数字-延伸题目" class="header-anchor">#</a> 找出排序数组中只出现一次的数字&amp;延伸题目</h4> <h4 id="_540-有序数组中的单一元素"><a href="#_540-有序数组中的单一元素" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/" target="_blank" rel="noopener noreferrer">540. 有序数组中的单一元素<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <blockquote><p>同<a href="https://leetcode-cn.com/problems/skFtm2/" target="_blank" rel="noopener noreferrer">剑指 Offer II 070. 排序数组中只出现一次的数字<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一样</p> <p>我的题解——<a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/javascriptyi-huo-er-fen-sou-suo-quan-ti-f6rzu/" target="_blank" rel="noopener noreferrer">[JavaScript]异或、二分搜索（全体二分查找乱序数组&amp;偶数二分查找有序数组）注释齐全<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h5 id="异或快捷解决"><a href="#异或快捷解决" class="header-anchor">#</a> 异或快捷解决</h5> <blockquote><p>540题中英文版有规定 ：Your solution must run in <code>O(log n)</code> time and <code>O(1)</code> space. 所以这个方法仅供了解</p> <p>主要考察二分法！</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">singleNonDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        res <span class="token operator">^=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="再优化-二分法-面试重点"><a href="#再优化-二分法-面试重点" class="header-anchor">#</a> 再优化，二分法（面试重点）</h5> <blockquote><p>这里的第一个关键点是先把四种情况列出来！</p> <p>参考官方题解</p> <p>例子 1：中间元素的同一元素在右边，且被 mid 分成两半的数组为偶数。</p> <p>我们将右子数组的第一个元素移除后，则右子数组元素个数变成奇数，我们应将 lo 设置为 mid + 2。</p> <p><img src="https://pic.leetcode-cn.com/08f1ff0fa20c9963ae4f5aafb7c6317df713b5eb562064ba8b7644c1d773c626-file_1576478245275" alt="在这里插入图片描述"></p> <p>例子 2：中间元素的同一元素在右边，且被 mid 分成两半的数组为奇数。</p> <p>我们将右子数组的第一个元素移除后，则右子数组的元素个数变为偶数，我们应将 hi 设置为 mid - 1。</p> <p><img src="https://pic.leetcode-cn.com/8481e9a41430c85977693dbad0d12de7df96a7064d13edd6eb359f7d8ccbcf99-file_1576478245283" alt="在这里插入图片描述"></p> <p>例子 3：中间元素的同一元素在左边，且被 mid 分成两半的数组为偶数。</p> <p>我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为奇数，我们应将 hi 设置为 mid - 2。</p> <p><img src="https://pic.leetcode-cn.com/186af681e3fced71c9588d9422accc7832062b24d33c343edecd9aef2e0c6ba1-file_1576478245286" alt="在这里插入图片描述"></p> <p>例子 4：中间元素的同一元素在左边，且被 mid 分成两半的数组为奇数。</p> <p>我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为偶数，我们应将 lo 设置为 mid + 1。</p> <p><img src="https://pic.leetcode-cn.com/067fab9a30b1b278da9e633de7b627931cdab5444d0f99e7142eb2907bff4431-file_1576478245290" alt="在这里插入图片描述"></p></blockquote> <p>然后就常规二分法做就行了~注意分情况讨论的细则即可！</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">singleNonDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义双指针</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// let mid = (i + j) &gt;&gt; 1;</span>
        <span class="token comment">// 为了防止大数溢出 建议这么写</span>
        <span class="token keyword">let</span> mid <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment">// 此方法的关键——判断哪边为奇数的变量 要设置好</span>
        <span class="token keyword">let</span> isEven <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> mid<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果j-mid为偶数 则去除中间两个值相同的元素并跳过它们之后，两指针（包括两指针）之间有奇数个元素，</span>
        <span class="token comment">// 也就是单个的元素一定在这之间</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>isEven<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">// 在左边</span>
                j <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{</span>
                i <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>isEven<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">// 在右边</span>
                i <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;last j&quot;</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>
                j <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>怎么说呢，双指针的题，多画图就完事了！</p> <p>时间复杂度 <code>O(logn)</code>，相比于暴力循环（包括异或），每次迭代将搜索空间缩减了一半！</p> <h5 id="进一步优化-仅对偶数索引进行二分搜索"><a href="#进一步优化-仅对偶数索引进行二分搜索" class="header-anchor">#</a> 进一步优化，仅对偶数索引进行二分搜索</h5> <p>最佳实践</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">singleNonDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 数组长度必为奇数，所以一前一后两个元素下标为偶数</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> mid <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>mid <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// mid为奇数则-1变为偶数 则mid现在必为“边缘” 不必再分四种情况来讨论</span>
            <span class="token comment">// 这就是仅对偶数索引进行二分搜索！</span>
            mid<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 去除mid那一对数之后，左侧数必为偶数，右侧数必为奇数，继续去紧挨着那对数的右边1个找</span>
            i <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token comment">// 去除mid那一对数之后，左侧数为奇数，右侧数必为偶数，继续去紧挨着那对数的左边1个找</span>
            j <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token comment">// 此时mid已经在原基础上左移一位了 所以j直接放在mid这个位置即可</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>时间复杂度：O(log n/2) = O(log<em>n</em>)。我们仅对元素的一半进行二分搜索。</li></ul> <h4 id="剑指-offer-56-i-数组中数字出现的次数"><a href="#剑指-offer-56-i-数组中数字出现的次数" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 56 - I. 数组中数字出现的次数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <h5 id="位运算-分组异或"><a href="#位运算-分组异或" class="header-anchor">#</a> 位运算-分组异或</h5> <p>这个分组的方法就很灵性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">singleNumbers</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 01 n 为 两个单独数a b的乘积</span>
    <span class="token comment">// 接下来(02中)使用与运算</span>
        <span class="token comment">// 与运算特点 二进制中只有6&amp;6 = 6 6&amp;0 = 0&amp;0 =0</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> num <span class="token keyword">of</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>
        n <span class="token operator">^=</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 02 m可以保证这个数组中单身的两个数a b中的一个可以不被它抵消掉 </span>
    <span class="token comment">// 也就是 m&amp;a = 0 m&amp;b != 0</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">&amp;</span> m<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 只要n&amp;m不为0 就一直让m左移，直到m可以抵消掉a与b中的一个</span>
        m <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 03 接下来使用m把两个单独的数分在两堆 并分组</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> num <span class="token keyword">of</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> m<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            x <span class="token operator">^=</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token punctuation">{</span>
            y <span class="token operator">^=</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>看不懂我这个解释（或者觉得太大白话） 可以看看 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/" target="_blank" rel="noopener noreferrer">K神的题解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="_10-滑动窗口"><a href="#_10-滑动窗口" class="header-anchor">#</a> 10.滑动窗口</h2> <h3 id="滑动窗口模板"><a href="#滑动窗口模板" class="header-anchor">#</a> 滑动窗口模板</h3> <p><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/" target="_blank" rel="noopener noreferrer">分享滑动窗口模板，秒杀滑动窗口问题 - 最大连续1的个数 III - 力扣（LeetCode） (leetcode-cn.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="经典题目"><a href="#经典题目" class="header-anchor">#</a> 经典题目</h3> <h4 id="_3-无重复字符的最长子串"><a href="#_3-无重复字符的最长子串" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener noreferrer">3. 无重复字符的最长子串<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <blockquote><p>滑窗模板题&amp;经典题</p></blockquote> <p>采用队列&amp;滑窗思想来解题:</p> <p>将新字符加入队列，重复字符出队。比如——</p> <p>​	队列里面有<code>QAQbc</code> 几个字符，第二个Q要入队的时候发现队列里面已经有a了，则去掉队列里的<code>QA</code>，再将新的Q插入，<strong>推动窗口向前</strong>。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> len<span class="token punctuation">;</span>
  <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cur <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 创建队列</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> idx <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断当前字符是否在队列中存在</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> cur<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新z</span>
      cur<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重复字符部分出队,因为不能返回子序列 所以把之前的全去掉——滑窗思想</span>
    <span class="token punctuation">}</span>
    cur<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 新字符入队</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>length<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>​</p> <h4 id="_1004-最大连续1的个数-iii"><a href="#_1004-最大连续1的个数-iii" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener noreferrer">1004. 最大连续1的个数 III<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <blockquote><p>好题！配合下面的动图题解 用来入门滑窗再合适不过了~</p></blockquote> <p><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/" target="_blank" rel="noopener noreferrer">分享滑动窗口模板，秒杀滑动窗口问题 - 最大连续1的个数 III <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="_2024-考试的最大困扰度"><a href="#_2024-考试的最大困扰度" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/" target="_blank" rel="noopener noreferrer">2024. 考试的最大困扰度<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <h4 id="_438-找到字符串中所有字母异位词"><a href="#_438-找到字符串中所有字母异位词" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener noreferrer">438. 找到字符串中所有字母异位词<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202111282204196.png" alt="image-20211128220400103"></p> <blockquote><p>非常棒的一题</p> <ul><li>很明显的（第一次做完全没看出来，惭愧！）滑动窗口的思想</li> <li>利用一维数组模拟哈希表（之前我一看见哈希表二话不说直接new Map()…）</li></ul></blockquote> <p>来看个图 很清晰了就 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/tong-ge-lai-shua-ti-la-hua-dong-chuang-k-xgkv/" target="_blank" rel="noopener noreferrer">来源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://pic.leetcode-cn.com/1638063958-WzvElV-file_1638063958629" alt="image-20211128090548278"></p> <p>注释齐全，这个方法是最最基础的固定窗口大小的滑动窗口，再困难一些的有窗口大小变动的<a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener noreferrer">76. 最小覆盖子串<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，嗯是个hard🥺</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">findAnagrams</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> p</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在滑动窗口中维护每种字母的数量（通过哈希表，注意哈希表不一定用Map数据结构哈，一维数组也ok 如本题经典的26个坑的哈希表——数组索引即为“键”，对应数组值即为“值”）</span>
    <span class="token keyword">const</span> sLen <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">,</span> pLen <span class="token operator">=</span> p<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sLen <span class="token operator">&lt;</span> pLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 这个判空一下子没想到XD</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 一维哈希表初始化下,初始化值为0</span>
    <span class="token keyword">const</span> hashS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> hashP <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 01 先建立起第一个窗口，顺便将hashP这个哈希表建立好</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        hashS<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        hashP<span class="token punctuation">[</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>hashS<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> hashP<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ans<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 02 将滑窗往后推，每轮推动将滑窗第一个位置的元素值-1，将滑窗末端下一个位置的元素值+1</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sLen <span class="token operator">-</span> pLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 滑动窗口的推动</span>
        hashS<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
        hashS<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i <span class="token operator">+</span> pLen<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>hashS<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> hashP<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ans<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_11-二分查找"><a href="#_11-二分查找" class="header-anchor">#</a> 11.二分查找</h2> <h2 id="_12-随机算法"><a href="#_12-随机算法" class="header-anchor">#</a> 12.随机算法</h2> <h3 id="数组的洗牌随机抽样"><a href="#数组的洗牌随机抽样" class="header-anchor">#</a> 数组的洗牌随机抽样</h3> <h4 id="_384-打乱数组"><a href="#_384-打乱数组" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/shuffle-an-array/" target="_blank" rel="noopener noreferrer">384. 打乱数组<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>最后一张牌跟随机一张交换位置 然后是倒数第二张 直到最后一张没“洗”过的（其实有可能已经变过位置勒 但是就是为了让每个索引处的都调整一下 公平嘛~）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">Solution</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>original <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Solution</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">reset</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 重设数组到它的初始状态并返回</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>original<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Solution</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">shuffle</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 洗牌算法 最终返回数组随机打乱的结构</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> j <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nums<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="链表的蓄水池抽样算法"><a href="#链表的蓄水池抽样算法" class="header-anchor">#</a> 链表的蓄水池抽样算法</h3> <h4 id="_382-链表随机节点"><a href="#_382-链表随机节点" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/linked-list-random-node/submissions/" target="_blank" rel="noopener noreferrer">382. 链表随机节点<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p><a href="https://leetcode-cn.com/problems/linked-list-random-node/solution/lian-biao-sui-ji-jie-dian-by-leetcode-so-x6it/" target="_blank" rel="noopener noreferrer">链表随机节点 - 链表随机节点<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201161216404.png" alt="image-20220116121627228"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">Solution</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> head
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Solution</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getRandom</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span> node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span> node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> i<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ans <span class="token operator">=</span> node<span class="token punctuation">.</span>val
        <span class="token punctuation">}</span>
        i<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ans
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/frontend-knowledge-base/handbook/struct.html" class="prev">
            前端必会数据结构
          </a></span> <span class="next"><a href="/frontend-knowledge-base/handbook/leetcode.html">
            推荐刷题内容
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_01-双指针" class="sidebar-link reco-side-_01-双指针" data-v-cb1513f6>01 双指针</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【1】链表中的双指针" class="sidebar-link reco-side-【1】链表中的双指针" data-v-cb1513f6>【1】链表中的双指针</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【2】有序数组中的双指针-求和、比大小" class="sidebar-link reco-side-【2】有序数组中的双指针-求和、比大小" data-v-cb1513f6>【2】有序数组中的双指针-求和、比大小</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【3】快慢指针" class="sidebar-link reco-side-【3】快慢指针" data-v-cb1513f6>【3】快慢指针</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_02-哈希表" class="sidebar-link reco-side-_02-哈希表" data-v-cb1513f6>02 哈希表</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#借助map的哈希表求解" class="sidebar-link reco-side-借助map的哈希表求解" data-v-cb1513f6>借助Map的哈希表求解</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#不借助map的哈希表求解" class="sidebar-link reco-side-不借助map的哈希表求解" data-v-cb1513f6>不借助Map的哈希表求解</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_03-递归" class="sidebar-link reco-side-_03-递归" data-v-cb1513f6>03 递归</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_04-dfs-bfs" class="sidebar-link reco-side-_04-dfs-bfs" data-v-cb1513f6>04 DFS BFS</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【1】dfs-深度优先搜索" class="sidebar-link reco-side-【1】dfs-深度优先搜索" data-v-cb1513f6>【1】DFS 深度优先搜索</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#二叉树中的dfs" class="sidebar-link reco-side-二叉树中的dfs" data-v-cb1513f6>二叉树中的DFS</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#为什么说dfs的本质是栈" class="sidebar-link reco-side-为什么说dfs的本质是栈" data-v-cb1513f6>为什么说DFS的本质是栈？</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【2】bfs广度优先搜索" class="sidebar-link reco-side-【2】bfs广度优先搜索" data-v-cb1513f6>【2】BFS广度优先搜索</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_05-回溯" class="sidebar-link reco-side-_05-回溯" data-v-cb1513f6>05 回溯</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【1】解题模板" class="sidebar-link reco-side-【1】解题模板" data-v-cb1513f6>【1】解题模板</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【2】递归回溯经典题目" class="sidebar-link reco-side-【2】递归回溯经典题目" data-v-cb1513f6>【2】递归回溯经典题目</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_06-排序问题" class="sidebar-link reco-side-_06-排序问题" data-v-cb1513f6>06 排序问题</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【1】简单排序" class="sidebar-link reco-side-【1】简单排序" data-v-cb1513f6>【1】简单排序</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【2】快速排序" class="sidebar-link reco-side-【2】快速排序" data-v-cb1513f6>【2】快速排序</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_07-动态规划" class="sidebar-link reco-side-_07-动态规划" data-v-cb1513f6>07 动态规划</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【1】轻松入门动态规划" class="sidebar-link reco-side-【1】轻松入门动态规划" data-v-cb1513f6>【1】轻松入门动态规划</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【2】使用动态规划解决复杂问题" class="sidebar-link reco-side-【2】使用动态规划解决复杂问题" data-v-cb1513f6>【2】使用动态规划解决复杂问题</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_08-前缀和" class="sidebar-link reco-side-_08-前缀和" data-v-cb1513f6>08 前缀和</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_09-位运算" class="sidebar-link reco-side-_09-位运算" data-v-cb1513f6>09 位运算</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【1】位运算基础知识" class="sidebar-link reco-side-【1】位运算基础知识" data-v-cb1513f6>【1】位运算基础知识</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#【2】位运算经典应用" class="sidebar-link reco-side-【2】位运算经典应用" data-v-cb1513f6>【2】位运算经典应用</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_10-滑动窗口" class="sidebar-link reco-side-_10-滑动窗口" data-v-cb1513f6>10.滑动窗口</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#滑动窗口模板" class="sidebar-link reco-side-滑动窗口模板" data-v-cb1513f6>滑动窗口模板</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#经典题目" class="sidebar-link reco-side-经典题目" data-v-cb1513f6>经典题目</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_11-二分查找" class="sidebar-link reco-side-_11-二分查找" data-v-cb1513f6>11.二分查找</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#_12-随机算法" class="sidebar-link reco-side-_12-随机算法" data-v-cb1513f6>12.随机算法</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#数组的洗牌随机抽样" class="sidebar-link reco-side-数组的洗牌随机抽样" data-v-cb1513f6>数组的洗牌随机抽样</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/handbook/algorithm.html#链表的蓄水池抽样算法" class="sidebar-link reco-side-链表的蓄水池抽样算法" data-v-cb1513f6>链表的蓄水池抽样算法</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/frontend-knowledge-base/assets/js/app.fcf437a8.js" defer></script><script src="/frontend-knowledge-base/assets/js/3.ceeb50c6.js" defer></script><script src="/frontend-knowledge-base/assets/js/1.8451d83f.js" defer></script><script src="/frontend-knowledge-base/assets/js/11.719e2e4d.js" defer></script>
  </body>
</html>
