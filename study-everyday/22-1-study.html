<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>22/1/12每日一题 | 前端知识库@敲代码的小提琴手</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="前端er的面试必备知识——前端算法与前端面试题！">
    
    <link rel="preload" href="/frontend-knowledge-base/assets/css/0.styles.1e7c64ec.css" as="style"><link rel="preload" href="/frontend-knowledge-base/assets/js/app.173ea465.js" as="script"><link rel="preload" href="/frontend-knowledge-base/assets/js/3.ceeb50c6.js" as="script"><link rel="preload" href="/frontend-knowledge-base/assets/js/1.8451d83f.js" as="script"><link rel="preload" href="/frontend-knowledge-base/assets/js/15.71d1729f.js" as="script"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/10.615e54db.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/11.9cb60eea.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/12.8c4cf6ad.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/13.10567183.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/14.a8bf8e79.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/16.c8100fbc.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/4.71c43d04.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/5.93f6240a.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/6.f3f5344e.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/7.76416851.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/8.d0d15fbd.js"><link rel="prefetch" href="/frontend-knowledge-base/assets/js/9.478ca27e.js">
    <link rel="stylesheet" href="/frontend-knowledge-base/assets/css/0.styles.1e7c64ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1aefc0b4><div data-v-1aefc0b4><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1aefc0b4 data-v-1aefc0b4><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>前端知识库@敲代码的小提琴手</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>前端er的面试必备知识——前端算法与前端面试题！</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-1aefc0b4><header class="navbar" data-v-1aefc0b4><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/frontend-knowledge-base/" class="home-link router-link-active"><!----> <span class="site-name">前端知识库@敲代码的小提琴手</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/frontend-knowledge-base/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      more about @敲代码的小提琴手
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myGithub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/18064101621133" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myJuejin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1aefc0b4></div> <aside class="sidebar" data-v-1aefc0b4><div class="personal-info-wrapper" data-v-39576ba9 data-v-1aefc0b4><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>4</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/frontend-knowledge-base/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      more about @敲代码的小提琴手
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/FangzhouSu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myGithub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/18064101621133" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  myJuejin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/" class="sidebar-heading clickable router-link-active"><span>Hey!This is 敲代码的小提琴手!</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/" aria-current="page" class="sidebar-link">学前必读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/handbook/start" class="sidebar-heading clickable"><span>前端er必会的数据结构与算法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/handbook/struct.html" class="sidebar-link">前端必会数据结构</a></li><li><a href="/frontend-knowledge-base/handbook/algorithm.html" class="sidebar-link">前端必会算法技巧</a></li><li><a href="/frontend-knowledge-base/handbook/leetcode.html" class="sidebar-link">推荐刷题内容</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/frontend-knowledge-base/study-everyday/study-everyday" class="sidebar-heading clickable open"><span>前端校招er必会的前端知识点</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend-knowledge-base/study-everyday/22-1-study.html" aria-current="page" class="active sidebar-link">22/1的每日一题</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-1aefc0b4><main class="page"><section><div class="page-title"><h1 class="title">22/1/12每日一题</h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="_22-1-12每日一题"><a href="#_22-1-12每日一题" class="header-anchor">#</a> <a href="https://github.com/FangzhouSu/FE-Harvester-studyEveryday/issues/1" target="_blank" rel="noopener noreferrer">22/1/12每日一题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h1> <blockquote><p>更多内容戳<a href="https://github.com/FangzhouSu/FE-Harvester-studyEveryday/issues/1" target="_blank" rel="noopener noreferrer">标题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>见讨论区嗷！</p></blockquote> <blockquote><p>1、CSS篇：定位中，absolute 与 fixed 共同点与不同点
2、JavaScript篇：闭包的概念及特点
3、算法：说一下递归和迭代的区别是什么，各有什么优缺点？
4、力扣101.对称二叉树：给你一个二叉树的根节点root，检查它是否轴对称。</p></blockquote> <h2 id="_1、css篇-定位中-absolute-与-fixed-共同点与不同点"><a href="#_1、css篇-定位中-absolute-与-fixed-共同点与不同点" class="header-anchor">#</a> 1、CSS篇：定位中，absolute 与 fixed 共同点与不同点</h2> <p>共同点：</p> <ul><li><p>改变行内元素的呈现方式，将 display 置为 <code>inline-block</code></p></li> <li><p>使元素<strong>脱离普通文档流</strong>，不再占据文档物理空间，<strong>触发BFC</strong></p></li> <li><p><strong>覆盖非定位文档元素</strong></p></li></ul> <p>不同点：</p> <ul><li><p>absolute 与 fixed 的<strong>根元素</strong>不同，absolute 的根元素可以设置，fixed 根元素是浏览器。</p></li> <li><p>在有滚动条的页面中，absolute 会跟着父元素进行移动，fixed 固定在页面的具体位置。</p></li> <li><p>absolute是相对于离它最近的有相对定位的父元素进行定位（一般使用子绝父相，如果没有定位的父元素则相对于浏览器窗口）；fixed是相对于浏览器窗口定位。</p></li></ul> <h2 id="_2、javascript篇-闭包的概念及特点"><a href="#_2、javascript篇-闭包的概念及特点" class="header-anchor">#</a> 2、JavaScript篇：闭包的概念及特点</h2> <blockquote><p>闭包的知识点有很多有趣的点！这里建议多看一些**<a href="https://github.com/FangzhouSu/FE-Harvester-studyEveryday/issues/1" target="_blank" rel="noopener noreferrer">例子<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>**学习一下，但也别太纠结！</p></blockquote> <blockquote><p><a href="https://github.com/FangzhouSu/FE-Harvester-studyEveryday/issues/1#issuecomment-1010670778" target="_blank" rel="noopener noreferrer">相关讨论<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <ul><li>1、概念</li></ul> <p>【1】闭包函数：声明在一个函数中的函数，叫做闭包函数，闭包函数可以访问其他函数内部变量。</p> <p>【2】内部函数引用外部函数的数据，并且<strong>外部函数执行就会产生闭包</strong>。</p> <p>【3】闭包：内部函数<strong>总是可以访问其所在的外部函数中声明的参数和变量</strong>，即使在其外部函数被返回（寿命终结）了之后。利用闭包可以<strong>突破作用域链</strong>。</p> <p>【4】使用闭包一般是为了<strong>设计私有的方法和属性</strong>。</p> <ul><li><p>2、特点（优点）</p> <ul><li>让<strong>外部访问函数内部变量</strong>成为可能；</li> <li>可以避免使用全局变量，<strong>防止全局变量污染</strong>；</li></ul></li> <li><p>3、缺点</p> <ul><li>【1】可能导致<em>内存溢出</em>（面试高频）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// new Array(1000000)定义一个长度为1000000的数组</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'------'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token comment">// 这个代码会导致内存溢出 浏览器会做一个崩溃的设置 终止程序</span>
</code></pre></div><p>内存溢出是指存储的数据超出了指定空间的大小，这时数据就会越界</p> <ul><li>【2】可能会导致<em>内存泄露</em></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">[</span><span class="token number">10000000</span><span class="token punctuation">]</span>
    <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> fn2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// fn1形成闭包 本该释放的arr变量现在不会被释放！</span>
</code></pre></div><p><strong>内存泄漏</strong>的意思：变量占用内存的事件可能会过长（毕竟延长了局部变量的生命周期嘛~ 申请的内存空间没有被正确释放，导致后续程序里这块内存被永远占用（不可达））——</p> <blockquote><p>简单来说就是：闭包会常驻内存，增加内存使用量。</p></blockquote> <p>所以需要及时释放——</p> <p>【2.1】解决内存泄漏的方法让<strong>内部函数对象</strong>f成为垃圾对象！！</p> <div class="language-js extra-class"><pre class="language-js"><code> f <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 解放空间！</span>
</code></pre></div><p>【2.2】我们可以利用垃圾回收机制销毁内存中的闭包或者手动销毁，上面提到了手动销毁，而垃圾回收机制有如下方法——</p> <ul><li>标记清除法</li> <li>循环计数法</li></ul></li></ul> <h2 id="_3、算法-说一下递归和迭代的区别是什么-各有什么优缺点"><a href="#_3、算法-说一下递归和迭代的区别是什么-各有什么优缺点" class="header-anchor">#</a> 3、算法：说一下递归和迭代的区别是什么，各有什么优缺点？</h2> <blockquote><p>这里感觉非常新奇呐！之前没有研究过！</p></blockquote> <p>（一）定义：</p> <ul><li><p><strong>递归</strong>: 递归常被用来描述以自相似方法重复事物的过程，在数学和开发中，指的是在函数定义中使用函数自身的方法；递归实际上不断地深层调用函数，直到函数有返回才会逐层的返回，递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，因此，递归涉及到运行时的堆栈开销（参数必须压入堆栈保存，直到该层函数调用返回为止），所以有可能导致堆栈溢出的错误；但是递归编程所体现的思想正是人们追求简洁、将问题交给计算机，以及将大问题分解为相同小问题从而解决大问题的动机。递归，还有个尾调用优化，尾调用优化就是如果本次调用的返回值，是子调用的返回值的话，本次调用就可以直接出栈了，不需要进行嵌套。就可以实现栈深为1的递归调用。递归从字面可以其理解为重复“递推”和“回归”的过程（递推：层层推进，分解问题；回归：层层回归，返回较大问题的解）</p> <blockquote><p>简单来说：程序调用自身称为递归</p></blockquote> <blockquote><ul><li>这里可以看我之前写的一篇剖析递归过程的文章<a href="https://juejin.cn/post/7016324095843237901#heading-0" target="_blank" rel="noopener noreferrer">掌握递归调用栈思想 由浅入深研究递归🎉 - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，带上图片和例子一起理解</li></ul></blockquote></li> <li><p><strong>迭代</strong>: 是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。迭代是顺序的，不涉及调用栈操作，前面的代码不会被后面代码影响，递归是涉及到调用栈的，遵循先入栈后结束后入栈先结束原则，前面的函数调用会阻塞，要在后面的调用返回值后才能继续执行，所以迭代的好处就是栈深小，但是代码逻辑不够清晰，递归则是嵌套调用多，栈深比较大，容易爆栈，但代码结构会比较简洁，速度的话还是迭代快。迭代大部分时候需要人为的对问题进行剖析，分析问题的规律所在，将问题转变为一次次的迭代来逼近答案。迭代不像递归那样对堆栈有一定的要求，另外一旦问题剖析完毕，就可以很容易的通过循环加以实现。迭代的效率高，但却不太容易理解，当遇到数据结构的设计时，比如图表、二叉树、网格等问题时，使用就比较困难，而是用递归就能省掉人工思考解法的过程，只需要不断的将问题分解直到返回就可以了。</p> <blockquote><p>简单来说：利用变量的原值推出新值称为迭代。</p></blockquote></li></ul> <p>（二）异同点：</p> <blockquote><p>了解一下递归和迭代的时间复杂度！感觉蛮加分的~</p></blockquote> <ul><li><p>相同点：递归和迭代都是循环的一种。</p></li> <li><p>不同点：</p> <ul><li>（1）<strong>程序结构不同</strong>：递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。 其中，迭代与普通循环的区别是：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</li> <li>（2）<strong>算法结束方式不同</strong>（递归的一大要素——结束条件）：递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。 当然很多情况都是多种循环混合采用，这要根据具体需求。</li> <li>（3）<strong>效率不同</strong>：在<strong>循环的次数较大的时候，迭代的效率明显高于递归</strong></li> <li>（4）<strong>运行过程不同</strong>，如果是循环迭代的话，这个整个就在主函数的或者在调用函数的栈空间里面，如果是递归的话，它会不断的申请函数调用的栈空间，在计算的过程中，计算一个结果，退一层栈，递归过程，在调用的时候有可能会出现栈的溢出。</li> <li>（5）理论上递归和迭代时间复杂度方面是一样的，但<strong>实际应用中（函数调用和函数调用堆栈的开销）递归比迭代效率要低</strong>。</li></ul></li></ul> <p>（三）优缺点</p> <ul><li><p>递归的</p> <ul><li>优点: 大问题转化为小问题，可以减少代码量，同时代码精简，可读性好。</li> <li>缺点: 递归调用<strong>浪费了空间</strong>（递归调用栈），而且递归太深容易造成堆栈的溢出。</li></ul></li> <li><p>迭代的</p> <ul><li>优点: 就是代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销。</li> <li>缺点: 就是代码不如递归简洁</li></ul></li></ul> <h2 id="_4、力扣101-对称二叉树"><a href="#_4、力扣101-对称二叉树" class="header-anchor">#</a> 4、<a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener noreferrer">力扣101.对称二叉树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <blockquote><p><a href="https://github.com/FangzhouSu/FE-Harvester-studyEveryday/issues/1#issuecomment-1010753085" target="_blank" rel="noopener noreferrer">相关讨论<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201121847142.png" alt="image-20220112184746023"></p> <ul><li><code>DFS深搜递归法</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先dfs深搜到最下面，验证局部对称性</span>
    <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 遍历到叶节点，返回true</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 遍历到只有一个子节点的节点，返回false</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 遍历到两个不相等的节点，返回false</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!==</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 递归比较左节点的左孩子和右节点的右孩子&amp;&amp;左节点的右孩子和右节点的左孩子</span>
        <span class="token comment">// 这一步 将递归函数dfs不断加入递归调用栈，进行局部对称性的验证</span>
        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>队列+迭代法</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//迭代方法判断是否是对称二叉树</span>
  <span class="token comment">//首先判断root是否为空</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> leftNode<span class="token operator">=</span>queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左节点</span>
      <span class="token keyword">let</span> rightNode<span class="token operator">=</span>queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右节点</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>leftNode<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>rightNode<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>leftNode<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">||</span>rightNode<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">||</span>leftNode<span class="token punctuation">.</span>val<span class="token operator">!==</span>rightNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左节点左孩子入队</span>
      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右节点右孩子入队</span>
      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左节点右孩子入队</span>
      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右节点左孩子入队</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>栈+迭代</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//迭代方法判断是否是对称二叉树</span>
  <span class="token comment">//首先判断root是否为空</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> rightNode<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左节点</span>
      <span class="token keyword">let</span> leftNode<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右节点</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>leftNode<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>rightNode<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>leftNode<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">||</span>rightNode<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">||</span>leftNode<span class="token punctuation">.</span>val<span class="token operator">!==</span>rightNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左节点左孩子入队</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右节点右孩子入队</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左节点右孩子入队</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右节点左孩子入队</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h1 id="_22-1-13每日一题"><a href="#_22-1-13每日一题" class="header-anchor">#</a> 22/1/13每日一题</h1> <blockquote><p>1.箭头函数与普通函数的区别?</p> <p>2.this指向哪⾥？</p> <p>3.扩展运算符的作用及使用场景?</p> <blockquote><p>仓管来加道经典题 大家来瞅一眼呗hh 昨天做了树 今天做个超级经典数组题吧！</p></blockquote> <p>4.<a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener noreferrer">217. 存在重复元素<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="_1-箭头函数与普通函数的区别"><a href="#_1-箭头函数与普通函数的区别" class="header-anchor">#</a> 1.箭头函数与普通函数的区别?</h2> <blockquote><p>1.箭头函数的参数只有一个时，可以省略小括号（但是！这里最好是<a href="https://github.com/lin-123/javascript#arrows--paren-wrap" target="_blank" rel="noopener noreferrer">带上括号<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>哦！），函数里面的执行语句只有一条时，可以省略花括号（但是！如果回调函数没有return 则<a href="https://github.com/lin-123/javascript#arrows--implicit-return" target="_blank" rel="noopener noreferrer">最好加上大括号<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ——减少副作用）
2.箭头函数本身没有this，它会<strong>继承作用域链上一层的this</strong>
3.箭头函数不能使用call, bind, apply来改变this指向</p></blockquote> <h4 id="_1-写法不一样"><a href="#_1-写法不一样" class="header-anchor">#</a> 1：写法不一样</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_2-普通函数存在变量提升的现象-箭头函数只会被提升变量"><a href="#_2-普通函数存在变量提升的现象-箭头函数只会被提升变量" class="header-anchor">#</a> 2：普通函数存在变量提升的现象 箭头函数只会被提升变量</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//普通函数</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//箭头函数</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//报错 foo is not a function</span>
<span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_3-箭头函数不能作为构造函数使用"><a href="#_3-箭头函数不能作为构造函数使用" class="header-anchor">#</a> 3：箭头函数不能作为构造函数使用</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span><span class="token keyword">let</span> xiao_ming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xiao_ming<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">//undefined</span>
</code></pre></div><h4 id="_4-两者this的指向不同"><a href="#_4-两者this的指向不同" class="header-anchor">#</a> 4：两者this的指向不同</h4> <p>普通函数的this指向的是谁调用该函数就指向谁</p> <p>箭头函数的this指向的是在你书写代码时候的上下文环境对象的this，如果没有上下文环境对象，那么就指向最外层对象window。</p> <h4 id="_5-箭头函数的arguments指向它的父级函数所在作用域的arguments"><a href="#_5-箭头函数的arguments指向它的父级函数所在作用域的arguments" class="header-anchor">#</a> 5：箭头函数的arguments指向它的父级函数所在作用域的arguments</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>  <span class="token keyword">let</span> <span class="token function-variable function">foo1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token comment">//[Arguments] { '0': 'test' }//[Arguments] { '0': 'test' }</span>
</code></pre></div><h4 id="_6-箭头函数没有new-target"><a href="#_6-箭头函数没有new-target" class="header-anchor">#</a> 6：箭头函数没有new.target</h4> <p>先说明下new.target是干嘛的，这家伙是用来检测函数是否被当做构造函数使用，他会返回一个指向构造函数的引用。</p> <p>因为箭头函数不能当做构造函数使用，自然是没有new.target的。</p> <h2 id="_2-this指向哪里"><a href="#_2-this指向哪里" class="header-anchor">#</a> 2.this指向哪里？</h2> <blockquote><p>其实this指向的问题情况并不多，但是它在不同的执行条件下可能会绑定（指向）不同的对象，如果想要再深入了解，可以看一下coderwhy的<a href="https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA" target="_blank" rel="noopener noreferrer">这篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <ul><li>普通函数中：this-&gt;window</li> <li>定时器中：this-&gt;window</li> <li>构造函数中：this-&gt;当前实例化的对象</li> <li>事件处理函数中：this-&gt;事件触发对象</li> <li>在 js 中一般理解就是<strong>谁调用这个 this 就指向谁</strong></li></ul> <h2 id="_3-扩展运算符的作用及使用场景"><a href="#_3-扩展运算符的作用及使用场景" class="header-anchor">#</a> 3.扩展运算符的作用及使用场景</h2> <h4 id="_0-将一个数组转为用逗号分隔的参数序列。"><a href="#_0-将一个数组转为用逗号分隔的参数序列。" class="header-anchor">#</a> 0.将一个数组转为用逗号分隔的参数序列。</h4> <blockquote><p>这里其实是以下几种方法的本质啦~</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 1 2 3console.log(1, ...[2, 3, 4], 5) //1 2 3 4 5</span>
</code></pre></div><h4 id="_1-普通函数中使用-用作参数"><a href="#_1-普通函数中使用-用作参数" class="header-anchor">#</a> 1.普通函数中使用，用作参数</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> <span class="token operator">...</span>items</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>numbers<span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre></div><h4 id="_2-替代-apply-方法-方便地将数组转变为可以传入函数的参数"><a href="#_2-替代-apply-方法-方便地将数组转变为可以传入函数的参数" class="header-anchor">#</a> 2.替代 apply 方法 方便地将数组转变为可以传入函数的参数</h4> <blockquote><p>本质也跟0是一样的~</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77);</span>
</code></pre></div><h4 id="_3-合并数组"><a href="#_3-合并数组" class="header-anchor">#</a> 3.合并数组</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// ES5的合并数组arr1.concat(arr2, arr3)  // [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]  // [ 'a', 'b', 'c', 'd', 'e' ]</span>
</code></pre></div><h4 id="_4-与解构赋值结合"><a href="#_4-与解构赋值结合" class="header-anchor">#</a> 4.与解构赋值结合</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>first <span class="token comment">// 1rest  // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest  // []const [first, ...rest] = [&quot;foo&quot;];first  // &quot;foo&quot;rest   // []</span>
</code></pre></div><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p> <blockquote><p>这个点之前还真没有注意~</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token operator">...</span>butLast<span class="token punctuation">,</span> last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];  // 报错</span>
</code></pre></div><h4 id="_5-将字符串转为数组"><a href="#_5-将字符串转为数组" class="header-anchor">#</a> 5.将字符串转为数组</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token comment">// ES5  var arr1 = str.split('');  // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] // ES6  var arr2 = [...str];  // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] </span>
</code></pre></div><h4 id="_6-实现了-iterator-接口的对象"><a href="#_6-实现了-iterator-接口的对象" class="header-anchor">#</a> 6.实现了 Iterator 接口的对象</h4> <p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> domList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>domList<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_7-数组-对象的浅拷贝"><a href="#_7-数组-对象的浅拷贝" class="header-anchor">#</a> 7.数组/对象的浅拷贝</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> copy <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> original <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> copy <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>original<span class="token punctuation">,</span> <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_4、217-存在重复元素"><a href="#_4、217-存在重复元素" class="header-anchor">#</a> 4、<a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener noreferrer">217. 存在重复元素<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>经典的数组查重问题！</p> <ul><li>【1】利用判重API <code>indexOf</code>构建去重辅助数组</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">containsDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>newArr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            newArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newArr<span class="token punctuation">.</span>length <span class="token operator">!==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>执行用时较高！想必是<code>indexOf</code>方法的锅咯~</p> <ul><li>【2】利用数据结构Set 构造只有单一元素的Set对象,判断Set对象与原数组长度是否相同</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">containsDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">return</span> newArr<span class="token punctuation">.</span>size <span class="token operator">!==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>同理 使用哈希表记录出现的次数也可以~</li></ul> <p>这里用Set其实更好哈~主要上面刚用过 换个口儿😄</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">containsDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>时间复杂度O(N)</p> <p>空间复杂度O(N)</p> <ul><li>【3】排序后冒泡比较</li></ul> <p>这里可以拓展炫技手写个排序出来？😏</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">containsDuplicate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    nums<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>时间复杂度O(N*log~N~)</p> <p>空间复杂度O(log~N~) 在这里应当考虑排序时递归调用栈的深度。</p> <blockquote><p>V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，</p> <ul><li>数量小于10的数组使用 <code>InsertionSort</code>-插入排序</li> <li>比10大的数组则使用 <code>QuickSort</code>-快速排序</li></ul> <p>详情见<a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js" target="_blank" rel="noopener noreferrer">V8 引擎array源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 710行开始 快排在760行处</p></blockquote> <ul><li>【4】说干就干！来手写个快排！参考之前写过的一篇<a href="https://blog.csdn.net/qq_45704942/article/details/116448702?spm=1001.2014.3001.5502" target="_blank" rel="noopener noreferrer">Java题解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（写得贼详细 每一步都拆分开来说了！），这篇文章是参考的leetcode主站的一篇<a href="https://leetcode-cn.com/problems/sort-an-array/solution/dong-hua-mo-ni-yi-ge-kuai-su-pai-xu-wo-x-7n7g/" target="_blank" rel="noopener noreferrer">优秀图解 by 袁厨<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>~（好家伙连环参考）</li></ul> <p>快排分以下几步</p> <p>1.选出基准值</p> <p>2.使用<a href="https://leetcode-cn.com/problems/sort-an-array/solution/dong-hua-mo-ni-yi-ge-kuai-su-pai-xu-wo-x-7n7g/" target="_blank" rel="noopener noreferrer">填坑法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，写一个partition函数将数组分为小于基准值和大于基准值两部分</p> <p>3.递归完成快排！</p> <p>下面代码里这个注释很清楚了吧！</p> <p>另外还写了个<a href="https://leetcode-cn.com/problems/sort-an-array/solution/javascriptjava-chao-xiang-xi-ti-jie-tian-dsvc/" target="_blank" rel="noopener noreferrer">题解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 搭配图看着更舒服哈~</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">sortArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// 调用快排方法    return nums};var quicksort = function(nums, low, high) {    if(low &lt; high) {        let index = partition(nums, low, high)// 得到用来将数组分成两部分（左面全小于index 右面全大于index）的索引        quicksort(nums, low, index - 1)// 以第一轮得出的index为基准划分出左半区和右半区 对数组的左半区进行递归 将其全部变为有序        quicksort(nums, index + 1, high)// 同理左半区    }}var partition = function(arr, low, high) {    let pivot = arr[low]// 选定第一个元素为基准值 把它拿出来 即为“挖坑”    while(low &lt; high) {        // 【1】 挖了坑就需要填坑~从high指针开始向左找         while(low &lt; high &amp;&amp; arr[high] &gt;= pivot) {            high--        }        arr[low] = arr[high]// 一旦找到比坑对应值pivot小的 就扔到low那侧的坑里        // 【2】 同【1】从low指针开始向右找填坑值        while(low &lt; high &amp;&amp; arr[low] &lt; pivot) {            low++        }        arr[high] = arr[low]// 一旦找到比坑对应值pivot大的 就扔到high那侧的坑里        //（刚刚这侧有一个值去填low那侧的坑了 所以出现了一个坑位~）    }    // 经过上面【1】【2】的不断迭代 low===high 此时这个位置即为基准位置    arr[low] = pivot    return low// 分区成功！返回定海神针~（此时low=high哦~）}</span>
</code></pre></div><blockquote><p>再拓展补充下~</p> <ul><li><p>不稳定的四种排序方法 <strong>快选希堆</strong></p></li> <li><p>最快的排序方法是<strong>归并排序</strong> 还有一个不常见的堆排序！ 时间复杂度为 n×log~n~</p> <ul><li>快速排序的平均时间复杂度是n×log~n~</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f79a76fa5224409bdcea8ed5cef1470~tplv-k3u1fbpfcp-zoom-1.awebp?" alt="img"></p></li> <li><p>归并排序和快速排序的区别：</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/431ac187d7ac4331abc3702407c3ab16~tplv-k3u1fbpfcp-zoom-1.awebp?" alt="img"></p> <ul><li>归并是先拆开 从底下往上面排</li> <li>快排是每次都打乱一下 从上往下排</li></ul></li></ul></blockquote> <h1 id="_22-1-14每日一题"><a href="#_22-1-14每日一题" class="header-anchor">#</a> 22/1/14每日一题</h1> <blockquote><p>1.讲一下强缓存和协商缓存的区别
2.如何解决跨越问题
3.对事件委托的理解以及其使用场景
4 算法，最大数</p></blockquote> <h2 id="_1-讲一下强缓存和协商缓存的区别"><a href="#_1-讲一下强缓存和协商缓存的区别" class="header-anchor">#</a> 1.讲一下强缓存和协商缓存的区别</h2> <blockquote><p>强缓存策略和协商缓存策略</p> <blockquote><p>字节二面原题orz 当时听都没听说过</p> <p>”啊？强缓存 对应的是弱缓存么？😫“  ”对应的是协商缓存😑😑“</p></blockquote> <ul><li><p>在缓存命中时<strong>都会直接使用本地的缓存副本</strong>；</p></li> <li><p>它们缓存不命中时，都会<strong>向服务器发送请求来获取资源</strong>。在实际的缓存机制中，强缓存策略和协商缓存策略是一起<strong>合作使用</strong>的。</p> <ul><li><strong>浏览器</strong>首先会根据请求的信息判断<strong>强缓存</strong>是否命中，【1】如果命中则直接使用本地资源的副本。如果不命中则【2】根据头信息向服务器发起请求，使用协商缓存——</li> <li>【3】如果<strong>协商缓存</strong>命中的话（资源没有过期，服务器响应报文状态码为304 临时重定向），则<strong>服务器</strong>不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则服务器返回最新的资源给浏览器。</li></ul></li></ul></blockquote> <h4 id="缓存技术实现"><a href="#缓存技术实现" class="header-anchor">#</a> 缓存技术实现</h4> <blockquote><p>对于一些具有重复性的HTTP请求 比如<strong>每次请求得到的数据都是一样的</strong> 我们就可以把这对<strong>请求-响应</strong>的数据都缓存在本地 那么下次就直接读取本地的数据 不必再通过网络获取服务器的响应了~</p></blockquote> <p>这样的话HTTP/1.1的性能肯定可以获得肉眼可见的提升！</p> <p>总结一下上面所说的 避免发送HTTP请求的方法 就是通过==缓存技术==来实现 HTTP设计者早在之前就考虑到了这点 因此<strong>HTTP协议的头部有不少是针对缓存的字段</strong></p> <h4 id="缓存技术实现细节"><a href="#缓存技术实现细节" class="header-anchor">#</a> 缓存技术实现细节</h4> <p>再来刨根问底一下 缓存是如何做到的呢？</p> <blockquote><p>【1】客户端会把<strong>第一次请求以及相应的数据保存在本地磁盘上</strong></p> <p>其中将请求的URL作为key 而响应作为value 两者形成映射关系 <strong>URL-&gt;响应</strong></p> <p>这样 当后续发起相同的请求时 就可以先在本地磁盘上通过key查到对应的value 也就是响应 （前提：资源没有过期）<img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201150051848.png" alt="image-20210810095837315"></p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201150051236.png" alt="image-20210810095923121"></p></blockquote> <h4 id="更新缓存的资源"><a href="#更新缓存的资源" class="header-anchor">#</a> 更新缓存的资源</h4> <p>看到这里 新的问题又会出现了——</p> <p>万一<strong>缓存的响应不是最新的</strong>，而客户端并不知情 那么该怎么办呢？</p> <p>这个问题HTTP的设计者也早已考虑到了~</p> <blockquote><p>服务器在发送HTTP响应时 会<strong>估算一个过期的时间</strong> 并把这个信息放到响应头部中——</p> <p>这样客户端在<strong>查看响应头部的信息时，【2】一旦发现缓存的响应是过期的，则就会重新发送网络请求</strong>。（强缓存命中则直接使用本地资源的副本。如果不命中则根据头信息向服务器发起请求，使用协商缓存，也就是接下来的【3】）</p></blockquote> <p>HTTP关于缓存说明的头部字段很多~这部分内容之后再仔细研究下 暂时不再拓展了</p> <h4 id="更新缓存资源细节"><a href="#更新缓存资源细节" class="header-anchor">#</a> 更新缓存资源细节</h4> <p>最后再来思考一个问题——</p> <blockquote><p>如果客户端从第⼀次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有 变更，还是⽼样⼦，那么你觉得还要在服务器的响应带上这个资源吗？</p> <p>很显然不带的话，可以提⾼ HTTP 协议的性能，那具体如何做到呢？</p></blockquote> <p>是啊 如果在重新发送请求的时候发现资源并没有变更 那么服务器在响应的时候应该返回什么资源呢？</p> <blockquote><p>【3】这个就需要我们在客户端重新发送请求时 <strong>在请求的 <code>Etag</code> 头部带上第一次请求的响应头部中的摘要</strong>，这个<u>摘要是唯一标识响应的资源</u>，当服务器收到请求后 会将本地资源的摘要（也就是最新的摘要） 与 请求中的摘要（缓存中的摘要）做个比较——</p> <ul><li>如果不同 说明客户端的缓存（URL-&gt;响应）已经没有价值 服务器将在响应中带上最新的资源。</li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201150112923.png" alt="image-20210810101411121"></p> <ul><li>如果相同 说明客户端的缓存还是可以继续使用的 那么服务器<strong>仅返回不含有包体的 <code>304 Not Modified</code> 响应</strong> 来告诉客户端“缓存的资源仍然有效哦！” 这样可以减少响应资源在网络中传输的延时！
<ul><li>==协商缓存==</li></ul></li></ul> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201150112612.png" alt="image-20210810101704953"></p></blockquote> <p>通过本个问题 - “如何避免发送HTTP请求” 对4个小点的研究</p> <p>我们发现每一个点都包含了“缓存”</p> <p>可以看出来 缓存真的是性能优化的一把万能钥匙！</p> <p>小到 CPU Cache、Page Cache、Redis Cache</p> <p>大到HTTP协议的缓存~</p> <h2 id="_2-如何解决跨越问题"><a href="#_2-如何解决跨越问题" class="header-anchor">#</a> 2.如何解决跨越问题</h2> <p>1.JSONP 使用script标签向后台请求数据，只适用于get请求
2.CORS是让服务器端设置Access-Control-Allow-Origin（头部字段），这样浏览器就不会报跨域错误
3.反向代理，搭建一个自己的服务器，让自己的服务器请求数据，拿到数据之后再返回给我自己</p> <h2 id="_3-对事件委托的理解以及其使用场景"><a href="#_3-对事件委托的理解以及其使用场景" class="header-anchor">#</a> 3.对事件委托的理解以及其使用场景</h2> <p>事件委托的本质是利用了<strong>浏览器事件冒泡</strong>的机制.</p> <p>因为<strong>事件在冒泡过程中会上传到父节点</strong>,父节点可以通过事件对象获取到目标节点,因此可以把子节点的监听函数定义在父节点上,由父节点的监听函数统一处理多个子元素的事件,这种方式称为事件委托</p> <p>事件委托的使用场景 :</p> <p>1.当存在多个元素可以共用同一个监听器</p> <p>2.用事件委托实现动态监控</p> <h2 id="_4-算法-最大数"><a href="#_4-算法-最大数" class="header-anchor">#</a> 4 算法，最大数</h2> <ul><li><code>巧妙排序</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">largestNumber</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> sorted <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">// 存在[0,0] [0,0,0]这种特殊情况 会出现00这种奇怪的答案，所以要删去多余的0    for (let i = 0; i &lt; sorted.length - 1; i++) {        if (sorted[i] === 0) {            sorted.splice(i, 1)            i--// 防止删除数组中某个元素之后造成的数组塌陷        }        else {            break        }    }    return sorted.join(&quot;&quot;)};</span>
</code></pre></div><blockquote><p>知识点：V8中sort函数的实现机制</p> <p><code>sort()</code> 方法用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FIn-place_algorithm" target="_blank" rel="noopener noreferrer">原地算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</p> <p>— MDN</p></blockquote> <blockquote><p>关于 <code>Array.prototype.sort()</code>  ，ES 规范并没有指定具体的算法，在 V8 引擎中，  <strong>7.0 版本之前</strong> ，数组长度小于10时， <code>Array.prototype.sort()</code> 使用的是插入排序，否则用快速排序。</p> <p>在 V8 引擎 <strong>7.0 版本之后</strong> 就舍弃了快速排序，因为它不是稳定的排序算法，在最坏情况下，时间复杂度会降级到 O(n2)。</p> <p>于是采用了一种混合排序的算法：<strong>TimSort</strong> 。</p> <p>这种功能算法最初用于Python语言中，严格地说它不属于以上10种排序算法中的任何一种，属于一种混合排序算法：</p> <p>在数据量小的子数组中使用<strong>插入排序</strong>，然后再使用<strong>归并排序</strong>将有序的子数组进行合并排序，时间复杂度为 <code>O(nlogn)</code> 。</p> <p>作者：an_371e
链接：https://www.jianshu.com/p/a557e9006186
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote> <h1 id="_22-1-18每日一题"><a href="#_22-1-18每日一题" class="header-anchor">#</a> 22/1/18每日一题</h1> <blockquote><ol><li>cookie sessionstorage localstorage 的区别</li> <li>浏览器的渲染过程</li> <li>渐进增强和优雅降级</li> <li>手写斐波那契数列</li></ol></blockquote> <h2 id="_1-cookie-sessionstorage-localstorage-的区别"><a href="#_1-cookie-sessionstorage-localstorage-的区别" class="header-anchor">#</a> 1.cookie &amp; sessionstorage &amp; localstorage 的区别</h2> <ul><li>共同点：都是保存在浏览器端，并且是同源的,都是<strong>字符串类型</strong>的键值对</li> <li>cookie数据始终在同源的http请求中携带，每次http请求都会携带cookie，cookie的数据大小不能超过4KB
<ul><li>sessionstorage和localstorage可以达到5MB</li></ul></li> <li>sessionstorage:仅在<strong>浏览器窗口关闭前有效</strong>，不能长久保存</li> <li>localstorage：数据始终有效，窗口或浏览器关闭也一直存在</li></ul> <h2 id="_2-浏览器的渲染过程"><a href="#_2-浏览器的渲染过程" class="header-anchor">#</a> 2.浏览器的渲染过程</h2> <p>【1】解析 HTML 构建DOM树</p> <p>【2】解析CSS 构建CSSOM树</p> <p>【3】利用上面两个树构建渲染树（渲染树的节点即为“渲染对象”）</p> <p>【4】渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以被称作“<strong>回流</strong>”）这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“<strong>自动重排</strong>”。</p> <p>【5】上述几步过后，布局结束；最后进行绘制，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p> <p>记住这张图：</p> <p><a href="https://camo.githubusercontent.com/ab5629cbfbeeaa676befdf1033d0481d37d67fc33c6979ff195752915959f6b4/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f313530303630342f313630333739373933393136352d33626635346532382d353436392d343039332d613065312d6530353639636563313330352e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/ab5629cbfbeeaa676befdf1033d0481d37d67fc33c6979ff195752915959f6b4/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f313530303630342f313630333739373933393136352d33626635346532382d353436392d343039332d613065312d6530353639636563313330352e706e67" alt="image"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_3-渐进增强和优雅降级"><a href="#_3-渐进增强和优雅降级" class="header-anchor">#</a> 3.渐进增强和优雅降级</h2> <ul><li>渐进增强:是针对低版本浏览器构建页面，保证最基本的功能，然后针对高版本浏览器进行效果，交互等改进并追加功能，达到更好的用户体验</li> <li>优雅降级：一开始就构建完整功能，然后<strong>对低版本浏览器进行兼容</strong>适配</li></ul> <h2 id="_4-手写斐波那契数列"><a href="#_4-手写斐波那契数列" class="header-anchor">#</a> 4.手写斐波那契数列</h2> <blockquote><p><a href="https://blog.csdn.net/zjxxyz123/article/details/80147546" target="_blank" rel="noopener noreferrer">递归，记忆化搜索与动态规划_Keep Learning-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>——感谢这篇很简单易懂的文章，帮我理解了<code>记忆化搜索+递归=(约等于)动态规划</code></p> <ul><li><strong>记忆化搜索和递归</strong>大致思路一样，是一种<strong>自顶向下</strong>的思路</li> <li><strong>动态规划</strong>则是一种<strong>自底向上</strong>的思路</li></ul></blockquote> <ul><li><code>超简单的递归</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">fb</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">fb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>递归树如下，可以看到存在大量重复计算
<img src="https://img-blog.csdn.net/2018043009544876?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqeHh5ejEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p> <ul><li><code>记忆化搜索</code>提升效率</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">let</span> <span class="token function-variable function">fb</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token punctuation">}</span>        <span class="token comment">// 这一步就是记忆化搜素新添的内容，使用一个数组来保存子问题的答案——这也正是动态规划的思想    if (memo[n]) {        return memo[n]    } else {        memo[n] = fb(n - 1) + fb(n - 2)    }    return memo[n]};</span>
</code></pre></div><ul><li><code>简单的动归解法</code> <ul><li>将原问题拆解成若干个子问题，同时<strong>保存子问题的答案</strong>——使得每个子问题只求解一次，最终获得原问题的答案~</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">fib</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h1 id="_22-1-19每日一题"><a href="#_22-1-19每日一题" class="header-anchor">#</a> 22/1/19每日一题</h1> <blockquote><p>​	1.字面量new出来的对象和Object.create(null)创建出来的对象有什么区别？</p> <ol start="2"><li>数据类型检测的方式都有哪些?</li> <li>判断数组检测的方式都有哪些?</li> <li>new的具体操作过程</li></ol></blockquote> <h2 id="_1-字面量new出来的对象和object-create-null-创建出来的对象有什么区别"><a href="#_1-字面量new出来的对象和object-create-null-创建出来的对象有什么区别" class="header-anchor">#</a> 1.字面量new出来的对象和Object.create(null)创建出来的对象有什么区别？</h2> <ul><li>new创建出来的对象会<strong>继承Object的方法和属性</strong>，创建出来的对象的隐式原型（<strong>proto</strong>)会指向Object的显示原型；</li> <li>而Object.create(null)创建出来的对象原型为null，作为<strong>原型链的顶端</strong>，就<strong>没有继承Object的方法和属性</strong>。</li></ul> <h2 id="_2-数据类型检测的方式都有哪些"><a href="#_2-数据类型检测的方式都有哪些" class="header-anchor">#</a> 2.数据类型检测的方式都有哪些?</h2> <p><strong>（1）typeof</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// numberconsole.log(typeof true);            // booleanconsole.log(typeof 'str');           // stringconsole.log(typeof []);              // object    console.log(typeof function(){});    // functionconsole.log(typeof {});              // objectconsole.log(typeof undefined);       // undefinedconsole.log(typeof null);            // object</span>
</code></pre></div><p>其中<strong>数组、对象、null</strong>都会被判断为object，其他判断都正确。</p> <p><strong>（2）instanceof</strong></p> <p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// falseconsole.log(true instanceof Boolean);                // false console.log('str' instanceof String);                // false  console.log([] instanceof Array);                    // trueconsole.log(function(){} instanceof Function);       // trueconsole.log({} instanceof Object);                   // true</span>
</code></pre></div><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而<strong>不能判断基本数据类型</strong>。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p> <p><strong>（3） constructor</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// trueconsole.log((true).constructor === Boolean); // trueconsole.log(('str').constructor === String); // trueconsole.log(([]).constructor === Array); // trueconsole.log((function() {}).constructor === Function); // trueconsole.log(({}).constructor === Object); // true</span>
</code></pre></div><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constructor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// falseconsole.log(f.constructor===Array); // true</span>
</code></pre></div><p><strong>（4）Object.prototype.toString.call()</strong></p> <p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'str'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p> <p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p> <h2 id="_3-判断数组检测的方式都有哪些"><a href="#_3-判断数组检测的方式都有哪些" class="header-anchor">#</a> 3 判断数组检测的方式都有哪些?</h2> <ul><li>通过<code>Object.prototype.toString.call()</code>做判断</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'Array'</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通过原型链做判断</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre></div><ul><li>通过ES6的Array.isArray()做判断</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Array.isArray(obj);
</code></pre></div><ul><li>通过instanceof做判断</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
</code></pre></div><ul><li>通过Array.prototype.isPrototypeOf</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre></div><h2 id="_4-new的具体操作过程"><a href="#_4-new的具体操作过程" class="header-anchor">#</a> 4. new的具体操作过程</h2> <blockquote><p>红宝书权威解释</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f493f86148bf4a3c888e34b6f6fd79c1~tplv-k3u1fbpfcp-watermark.awebp?" alt="image.png"></p></blockquote> <p>更细致的内容之前我有总结过一篇，相当于是手写<code>new Object</code>吧~<a href="https://juejin.cn/post/7012887169878458404" target="_blank" rel="noopener noreferrer">JS小知识 new关键字都做了什么？ - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="_1-20每日一题"><a href="#_1-20每日一题" class="header-anchor">#</a> 1/20每日一题</h1> <blockquote><p>1、实现一个三角形
2、JavaScript为什么要进行变量提升，它导致了什么问题？
3、实现节流函数和防抖函数</p></blockquote> <h1 id="_1-21每日一题"><a href="#_1-21每日一题" class="header-anchor">#</a> 1/21每日一题</h1> <blockquote><p>1.HTTP: 1.0 1.1 2.0 3.0对应的改进点，2.0实现多路复用的底层原理？</p> <p>2.Js:  call、apply、bind作用和区别</p> <p>3.数据结构: Map 和 Set 的区别</p></blockquote> <h2 id="_1-http-1-0-1-1-2-0-3-0对应的改进点-2-0实现多路复用的底层原理"><a href="#_1-http-1-0-1-1-2-0-3-0对应的改进点-2-0实现多路复用的底层原理" class="header-anchor">#</a> 1.HTTP: 1.0 1.1 2.0 3.0对应的改进点，2.0实现多路复用的底层原理？</h2> <h3 id="http-1-0和-http-1-1-有以下区别"><a href="#http-1-0和-http-1-1-有以下区别" class="header-anchor">#</a> <strong>HTTP 1.0和 HTTP 1.1</strong> <strong>有以下区别</strong>：</h3> <ul><li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li> <li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li> <li>3.数据结构: Map 和 Set 的区别<strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li> <li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li> <li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li></ul> <h3 id="http-1-1-和-http-2-0-的区别"><a href="#http-1-1-和-http-2-0-的区别" class="header-anchor">#</a> HTTP 1.1 和 HTTP 2.0 的区别</h3> <ul><li><strong>二进制协议</strong>：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li> <li>**多路复用：**HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了&quot;队头堵塞&quot;【1】的问题。</li> <li>**数据流：**HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li> <li>**头信息压缩：**HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li> <li>**服务器推送：**HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul> <h3 id="http3-0的特点"><a href="#http3-0的特点" class="header-anchor">#</a> HTTP3.0的特点</h3> <p>HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-9b0f553d-3c6e-43a3-8185-8565f9fa1fb4.webp" alt="image"></p> <ol><li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li> <li>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</li> <li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li></ol> <p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-5d0a5de2-00db-425e-8b21-0cc4bbb54b24.webp" alt="image"></p> <ol start="4"><li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。</li></ol> <h2 id="_2-call-和-apply-bind"><a href="#_2-call-和-apply-bind" class="header-anchor">#</a> 2.call() 和 apply() bind()</h2> <p>它们的作用一模一样，区别仅在于<strong>传入参数的形式的不同</strong>。</p> <ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li> <li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul> <p><strong>（1）call 函数的实现步骤：</strong></p> <ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li> <li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li> <li>处理传入的参数，截取第一个参数后的所有参数。</li> <li>将函数作为上下文对象的一个属性。</li> <li>使用上下文对象来调用这个方法，并保存返回结果。</li> <li>删除刚才新增的属性。</li> <li>返回结果。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 判断调用对象  if (typeof this !== &quot;function&quot;) {    console.error(&quot;type error&quot;);  }  // 获取参数  let args = [...arguments].slice(1),    result = null;  // 判断 context 是否传入，如果未传入则设置为 window  context = context || window;  // 将调用函数设为对象的方法  context.fn = this;  // 调用函数  result = context.fn(...args);  // 将属性删除  delete context.fn;  return result;};</span>
</code></pre></div><p><strong>（2）apply 函数的实现步骤：</strong></p> <ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li> <li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li> <li>将函数作为上下文对象的一个属性。</li> <li>判断参数值是否传入</li> <li>使用上下文对象来调用这个方法，并保存返回结果。</li> <li>删除刚才新增的属性</li> <li>返回结果</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 判断调用对象是否为函数  if (typeof this !== &quot;function&quot;) {    throw new TypeError(&quot;Error&quot;);  }  let result = null;  // 判断 context 是否存在，如果未传入则为 window  context = context || window;  // 将函数设为对象的方法  context.fn = this;  // 调用方法  if (arguments[1]) {    result = context.fn(...arguments[1]);  } else {    result = context.fn();  }  // 将属性删除  delete context.fn;  return result;};</span>
</code></pre></div><p><strong>（3）bind 函数的实现步骤：</strong></p> <ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li> <li>保存当前函数的引用，获取其余传入参数值。</li> <li>创建一个函数返回</li> <li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 判断调用对象是否为函数  if (typeof this !== &quot;function&quot;) {    throw new TypeError(&quot;Error&quot;);  }  // 获取参数  var args = [...arguments].slice(1),    fn = this;  return function Fn() {    // 根据调用方式，传入不同绑定值    return fn.apply(      this instanceof Fn ? this : context,      args.concat(...arguments)    );  };};</span>
</code></pre></div><h2 id="_3-数据结构-map-和-set-的区别"><a href="#_3-数据结构-map-和-set-的区别" class="header-anchor">#</a> 3.数据结构: Map 和 Set 的区别</h2> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <p><code>Map</code>对象<strong>保存键值对</strong>。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数<code>Map</code>可以接受一个数组作为参数。</p> <p><strong>Map和Object的区别</strong></p> <ul><li>一个<code>Object</code> 的键只能是字符串或者 <code>Symbols</code>，但一个<code>Map</code> 的键可以是任意值。</li> <li><code>Map</code>中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li> <li><code>Map</code>的键值对个数可以从 size 属性获取，而 <code>Object</code> 的键值对个数只能手动计算。</li> <li><code>Object</code> 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li></ul> <p><strong>Map对象的属性</strong></p> <ul><li>size：返回Map对象中所包含的键值对个数</li></ul> <p><strong>Map对象的方法</strong></p> <ul><li>set(key, val): 向Map中添加新元素</li> <li>get(key): 通过键值查找特定的数值并返回</li> <li>has(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false</li> <li>delete(key): 通过键值从Map中移除对应的数据</li> <li>clear(): 将这个Map中的所有元素删除</li></ul> <p><strong>map与其他数据结构的互相转换</strong></p> <ul><li><code>Map</code>与对象的互换</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span>value<span class="token punctuation">]</span> <span class="token keyword">of</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>  obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// {a:111, b: 222}</span>
</code></pre></div><ul><li><code>JSON</code>字符串要转换成<code>Map</code>可以先利用JSON.parse()转换成数组或者对象，然后再转换即可。</li></ul> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <p><code>Set</code>对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，<strong>没有重复的值</strong>。</p> <p><code>Set</code> 本身是一个构造函数，用来生成<code>Set</code> 数据结构。<code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p> <p><strong>Set中的特殊值</strong></p> <p><code>Set</code> 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p> <ul><li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复</li> <li>undefined 与 undefined 是恒等的，所以不重复</li> <li>NaN 与 NaN 是不恒等的，但是在 Set 中认为NaN与NaN相等，所有只能存在一个，不重复。</li></ul> <p><strong>Set实例对象的属性</strong></p> <ul><li>size：返回Set实例的成员总数。</li></ul> <p><strong>Set实例对象的方法</strong></p> <ul><li><code>add(value)</code>：添加某个值，返回 Set 结构本身(可以链式调用)。</li> <li><code>delete(value)</code>：删除某个值，删除成功返回<code>true</code>，否则返回<code>false</code>。</li> <li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li> <li><code>clear()</code>：清除所有成员，没有返回值。</li></ul> <p><strong>遍历方法</strong></p> <ul><li><code>keys()</code>：返回键名的遍历器。</li> <li><code>values()</code>：返回键值的遍历器。</li> <li><code>entries()</code>：返回键值对的遍历器。</li> <li><code>forEach()</code>：使用回调函数遍历每个成员。</li></ul> <p>由于<code>Set</code>结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p> <p><strong>Set 对象作用</strong></p> <ul><li>数组去重(利用扩展运算符)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> mySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">...</span>mySet<span class="token punctuation">]</span> <span class="token comment">// [1, 2, 3, 4]</span>
</code></pre></div><ul><li>合并两个set对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> union <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// {1, 2, 3, 4}</span>
</code></pre></div><ul><li>交集</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> intersect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> b<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// {2, 3} 利用数组的filter方法</span>
</code></pre></div><ul><li>差集</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> difference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>b<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//  {1} </span>
</code></pre></div><h3 id="二者区别"><a href="#二者区别" class="header-anchor">#</a> 二者区别</h3> <p>综上所述，主要有一下几个<strong>区别</strong>：</p> <p>1.<strong>Map是键值对，Set是值的集合</strong>，当然键和值可以是任何的值；</p> <p>2.Map可以通过get方法获取值，而set不能因为它只有值；</p> <p>3.都能通过迭代器进行for...of遍历；</p> <p>4.<strong>Set的值是唯一的可以做数组去重，Map由于没有格式限制，可以做数据存储</strong></p> <p>5.map和set都是stl中的关联容器，map以键值对的形式存储，key=&gt;value组成pair，是一组映射关系。set只有值，可以认为只有一个数据，并且set中元素不可以重复且自动排序。</p> <h1 id="_1-22-每日一题"><a href="#_1-22-每日一题" class="header-anchor">#</a> 1/22 每日一题</h1> <blockquote><ol><li>JavaScript中对象继承的方式有哪些</li> <li>实现脚本异步加载方法的关键字有哪些</li> <li>什么是JS事件循环，事件循环机制是什么</li> <li>力扣第20题有效的括号</li></ol></blockquote> <h2 id="_1-javascript中对象继承的方式有哪些"><a href="#_1-javascript中对象继承的方式有哪些" class="header-anchor">#</a> 1. JavaScript中对象继承的方式有哪些？</h2> <ul><li><p>原型式继承</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 原型式继承// Object()可以理解为对传入的对象进行一个浅复制let person = {    name: 'szj',    friends: ['zy', 'wjr', 'ghk']}let me = Object(person);me.friends.push('ssss')console.log(me);console.log(person)//{ name: 'szj', friends: [ 'zy', 'wjr', 'ghk', 'ssss' ] }//{ name: 'szj', friends: [ 'zy', 'wjr', 'ghk', 'ssss' ] }</span>
</code></pre></div></li></ul></li> <li><p>寄生式继承</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 寄生继承// 像是对原型继承的另一种升级 , 采用了工厂模式的方法 增加了对象的方法let jisheng = {    name : 'sss',    friends: ['ss' , 'www']}const js = (obj) =&gt;{      const clone = Object(obj);      clone.sayHi = function (){          console.log(clone.name);      }      return clone}const m = js(jisheng);m.sayHi();// sss</span>
</code></pre></div></li></ul></li> <li><p>组合继承</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 组合继承// 原型链 ＋ 盗用构造函数function Super(name){        this.name = name;        this.friends = ['szj' , 'zy'];}Super.prototype.sayName  = function (){    console.log(this.name);}function Sub(name){        // 盗用构造函数        Super.call(this , name);}// 原型链继承Sub.prototype = new Super;const bob  = new Sub('szj');bob.sayName()console.log(bob.friends);// szj// [ 'szj', 'zy' ]</span>
</code></pre></div></li></ul></li> <li><p>寄生式组合继承</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 寄生式组合继承// 最佳实践!! 相比于组合继承 减少了构造函数调用的次数function Superr (name){    this.name = name;    this.friends = ['ss' , 'www' , 'ppp'];}Superr.prototype.say = function (){    console.log(this.name);}function Subb(name){    Superr.call(this , name)}function inheritPrototype (sub , superr) {    const prototype = Object(superr.prototype);    // 别忘了原型对象的指向    prototype.constructor = sub;    sub.prototype = prototype;}inheritPrototype(Subb , Superr);const zy = new Subb('zy');zy.say()console.log(zy.friends);    // zy    // [ 'szj', 'zy' ]</span>
</code></pre></div></li></ul></li></ul> <h2 id="_2-实现异步加载方法的关键字有哪些"><a href="#_2-实现异步加载方法的关键字有哪些" class="header-anchor">#</a> 2. 实现异步加载方法的关键字有哪些？</h2> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png" alt="image.png"></p> <ul><li>defer</li> <li>async</li> <li>总结：
<ul><li>两者都是用来异步加载外部脚本的关键字</li> <li>defer 加载完成后 页面渲染后执行</li> <li>async 加载完成后 立即执行</li> <li><strong>多个 defer 按顺序依次执行</strong>  ， 多个async执行顺序不定</li></ul></li></ul> <h2 id="_3-什么是js的事件循环-事件循环机制是什么"><a href="#_3-什么是js的事件循环-事件循环机制是什么" class="header-anchor">#</a> 3. 什么是JS的事件循环 ， 事件循环机制是什么？</h2> <p><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476500217-472563e1-de67-403f-baa7-0fd574d0e618.png?x-oss-process=image%2Fresize%2Cw_1500" alt="image"></p> <p>如图： JS是单线程的 ， 在代码执行时，会将代码压入执行栈中保证函数的有序执行 ， 遇到异步任务会将 任务抛给webapi进行处理 ， 处理之后将回调函数推到任务队列（宏任务队列 ， 微任务队列） ， 当执行栈为空时 ， 先执行微任务队列中的函数 ， 如果需要渲染页面 ， 则会渲染页面 ， 最后执行宏任务队列中的函数。</p> <p>Event Loop 执行顺序如下所示：</p> <ul><li>首先执行同步代码，这属于宏任务</li> <li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li> <li>执行所有微任务</li> <li>当执行完所有微任务后，<strong>如有必要会渲染页面</strong></li> <li>然后开始下一轮 Event Loop，执行宏任务中的异步代码</li></ul> <p>宏任务</p> <ul><li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li> <li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</li></ul> <h2 id="_4-leetcode-20-有效的括号"><a href="#_4-leetcode-20-有效的括号" class="header-anchor">#</a> 4 <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener noreferrer">leetcode 20 有效的括号 <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/** * @param {string} s * @return {boolean} */</span><span class="token keyword">var</span> <span class="token function-variable function">isValid</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">const</span> c <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">===</span> <span class="token string">'{'</span> <span class="token operator">||</span> c <span class="token operator">===</span> <span class="token string">'['</span> <span class="token operator">||</span> c <span class="token operator">===</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">const</span> m <span class="token operator">=</span> stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">===</span> <span class="token string">'{'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">===</span> <span class="token string">'}'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>m<span class="token operator">===</span><span class="token string">'['</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">===</span> <span class="token string">']'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">===</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">===</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>@<a href="https://leetcode-cn.com/u/billsu/" target="_blank" rel="noopener noreferrer">敲代码的小提琴手<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isValid</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token string">'{'</span><span class="token punctuation">,</span> <span class="token string">'}'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token string">'['</span><span class="token punctuation">,</span> <span class="token string">']'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 找到左括号 入栈      stack.push(s[i]);     } else if (map.get(stack[stack.length - 1]) !== s[i]) {      // 左右括号不匹配 字符串无效      return false;     } else {      // 找到匹配得右括号 弹栈      stack.pop();     }  }  return !stack.length;};</span>
</code></pre></div><h1 id="_1-23-每日一题"><a href="#_1-23-每日一题" class="header-anchor">#</a> 1/23 每日一题</h1> <blockquote><ol><li>let、const、var区别</li> <li>数组去重的方法有哪些？</li> <li>vue双向绑定的原理</li> <li>力扣第70题 爬楼梯</li></ol></blockquote> <h2 id="_1-let、const、var区别"><a href="#_1-let、const、var区别" class="header-anchor">#</a> 1. let、const、var区别</h2> <blockquote><p>能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var</p></blockquote> <ul><li>作用域
<ul><li>let 、 const 为块级作用域</li> <li>var为函数作用域</li></ul></li> <li>是否可以重复声明
<ul><li>let var 可以重复声明</li> <li>const 不可以重复声明</li></ul></li> <li>变量提升
<ul><li>var 具有变量提升</li></ul></li> <li>暂时性死区
<ul><li>let 、const 具有暂时性死区 ， 未声明之后不能使用</li></ul></li> <li>给全局添加属性
<ul><li>var 可以给全局添加属性 let const 不会</li></ul></li> <li>初始值设置
<ul><li>var let 声明时可以不设置初始值</li> <li>const 必须设置初始值</li></ul></li> <li>指针的指向
<ul><li>let 可以修改指针的指向（重新赋值） ， const 不能够修改指针的指向不可以重新赋值，但是引用数据类型的属性可以改变</li></ul></li></ul> <table><thead><tr><th><strong>区别</strong></th> <th><strong>var</strong></th> <th><strong>let</strong></th> <th><strong>const</strong></th></tr></thead> <tbody><tr><td>是否有块级作用域</td> <td>×</td> <td>✔️</td> <td>✔️</td></tr> <tr><td>是否存在变量提升</td> <td>✔️</td> <td>×</td> <td>×</td></tr> <tr><td>是否添加全局属性</td> <td>✔️</td> <td>×</td> <td>×</td></tr> <tr><td>能否重复声明变量</td> <td>✔️</td> <td>×</td> <td>×</td></tr> <tr><td>是否存在暂时性死区</td> <td>×</td> <td>✔️</td> <td>✔️</td></tr> <tr><td>是否必须设置初始值</td> <td>×</td> <td>×</td> <td>✔️</td></tr> <tr><td>能否改变指针指向</td> <td>✔️</td> <td>✔️</td> <td>×</td></tr></tbody></table> <h2 id="_2-数组去重-的方法有哪些"><a href="#_2-数组去重-的方法有哪些" class="header-anchor">#</a> 2. ==数组去重==的方法有哪些？</h2> <h5 id="_1-数组元素比较型"><a href="#_1-数组元素比较型" class="header-anchor">#</a> 1. 数组元素比较型</h5> <ul><li><p>双层<code>for</code>循环</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 双层for循环// 前一个跟之后所有进行比较 ， 重复了删除掉function uniq(arr){	for(let i = 0 ; i &lt; arr.length - 1 ; i++){		for(let j = i + 1 ; j &lt; arr.length; j++){			if(arr[i] === arr[j]){				arr.splice(i , 1);				// 删除后下表移动到原位置				j--;			}		}	}	return arr;}</span>
</code></pre></div></li></ul></li> <li><p>排序后 相邻位置进行比较</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 排序进行后进行相邻比较function sortQ(arr){	// 排序后	// 没参数 如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。	arr.sort();	for(let i = 0 ; i &lt; arr.length - 1 ; i++){		if(arr[i] === arr[i + 1]){			arr.splice(i , 1);			i--;		}	}}</span>
</code></pre></div></li></ul></li></ul> <h5 id="_2-查找元素位置型"><a href="#_2-查找元素位置型" class="header-anchor">#</a> 2.查找元素位置型</h5> <ul><li><p><code>indexOf</code> 查找元素并返回其第一个索引值</p> <blockquote><p>这个方法有点秀哦！利用<code>indexOf</code> API的特性，且效率也是最佳！</p></blockquote> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>		<span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>			res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>		<span class="token punctuation">}</span>	<span class="token punctuation">}</span>	<span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p><code>findIndex</code>  返回数组中第一个满足测试函数的元素的索引</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>		<span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> item <span class="token operator">===</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> i <span class="token punctuation">)</span><span class="token punctuation">{</span>			res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token punctuation">}</span>	<span class="token punctuation">}</span>	<span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul> <h5 id="_3-查找元素存在型"><a href="#_3-查找元素存在型" class="header-anchor">#</a> 3. 查找元素存在型</h5> <ul><li><p><code>includes</code></p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 查找元素存在型function uniq(arr){	const res = [];	for(let i = 0 ; i &lt; arr.length ; i++){		if(!res.includes(arr[i])){			res.push(arr[i])		}	}	return res;}</span>
</code></pre></div></li></ul></li></ul> <h5 id="_4-利用数据结构类型"><a href="#_4-利用数据结构类型" class="header-anchor">#</a> 4. 利用数据结构类型</h5> <ul><li><p>set</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// setfunction uniq(arr){	return [...new Set(arr)]}</span>
</code></pre></div></li></ul></li> <li><p>map</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>		map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>	<span class="token punctuation">}</span><span class="token punctuation">)</span>	<span class="token comment">// 返回键值 Object.keys（key）	return[...map.keys()]}</span>
</code></pre></div></li></ul></li></ul> <h5 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> 5. 总结</h5> <p>在简单的测试用例大概 2000 万条数据下，<code>indexOf</code> 的方案速度相对最快</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/26/16f423b56fc0c430~tplv-t2oaga2asx-watermark.awebp" alt="img"></p> <h2 id="_3-vue双向绑定的原理"><a href="#_3-vue双向绑定的原理" class="header-anchor">#</a> 3. vue双向绑定的原理</h2> <ul><li>Mvc 模式  到  mvvm模式 的转变</li></ul> <p><img src="https://wfx7jb3ja4.feishu.cn/space/api/box/stream/download/asynccode/?code=NWVkNGQyYzg4MzMyMjcxZDViZmY1OGEyN2NhZTY4OTlfZWdGbzdlY1NsVEFDYTNCQW1sWTl3eU8xWHJXS092VlJfVG9rZW46Ym94Y253MG5TenpERXBPNTlXNHlqVzVocXBoXzE2NDI5NDcyMTI6MTY0Mjk1MDgxMl9WNA" alt="img"></p> <ul><li><p>Mvc 模式 controler 层要大量的控制dom</p></li> <li><p>Mvvm 模式 是真正做到了数据与视图的分离，  view 和 model 改变时 ， vm层自动进行数据和视图的同步</p></li> <li><p>vue.js 采用数据劫持结合发布者-订阅者模式的方式 ， 通过Object.defineProperty()来劫持各个属性的setter、getter，在数据监听时发布消息给订阅者 ， 触发响应的监听回调</p></li> <li><p>发布 订阅者模式让双向绑定更有效率（一对多）</p></li> <li><p>实现一个数据监听器 Observer</p> <ul><li>核心是 Object.defineProperty() ， 将Observe的数据对象进行递归遍历 ， 包括子属性的对象加上setter getter方法 ， 赋值时就会调用setter方法，就监听到了数据变化</li> <li>通知订阅者</li></ul></li> <li><p>实现Compile</p> <ul><li>解析模板的指令 ， 将模板中的变量替换成数据 ，</li> <li>初始化页面渲染 ，</li> <li>并绑定更新函数 ， 添加监听数据的订阅者 ， 一但数据有变化 ， 更新视图 --绑定更新函数</li></ul></li> <li><p>实现watcher （解析 compile 和 observe 的桥梁）</p> <ul><li>实例化在订阅者添加自己</li> <li>自己有一个update()方法  --添加订阅者</li> <li>待属性变动 ， 接受通知，调用自身的update() , 并触发compile中的回调 --》更新视图</li></ul></li> <li><p>整合形成一个mvvm</p></li></ul> <p><img src="https://wfx7jb3ja4.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWEyMjFkYTYxNTc1MWFjNmE5OWU5ZmI0YjA0ZmUyZDhfa3k5Tzdud1p0ZzQ0cURsZHk1dUo5VVRudXFDd2dRb3hfVG9rZW46Ym94Y240cmRGa1kwYnloNDlWTnA4YzR1dVhmXzE2NDI5NDcyMTI6MTY0Mjk1MDgxMl9WNA" alt="img"></p> <h2 id="_4-70-爬楼梯-力扣-leetcode-leetcode-cn-com"><a href="#_4-70-爬楼梯-力扣-leetcode-leetcode-cn-com" class="header-anchor">#</a> 4.<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">70. 爬楼梯 - 力扣（LeetCode） (leetcode-cn.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <blockquote><p>和斐波那契数列问题异曲同工~</p> <p>很easy！</p></blockquote> <ul><li><p><strong>记忆化递归</strong></p> <blockquote><p>理解记忆化递归 为自己的面试加分！</p> <ul><li>使用数组存储中间结果；</li> <li>中间结果如果存在，则不要重复使用递归式进行计算！</li></ul></blockquote> <p>由于递归太耗时，可以用记忆化递归避免重复的计算。
<strong>解题过程：</strong>
1.先对n为0这种特殊情况进行处理，然后n为1和2时直接return即可
2.memo数组：存储中间结果，避免重复计算
3.接下来就是判断memo[n]是否存在，如果计算过即存在，直接返回，无需重复计算；若不存在，则进行递归计算，为前两个之和。
<strong>代码</strong></p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n        <span class="token comment">// 记忆化递归 避免重复计算    if(memo[n]) {        return memo[n]    } else {        memo[n] = climbStairs(n-1) + climbStairs(n-2)    }    return memo[n]}</span>
</code></pre></div><ul><li><p>经典动归问题</p> <p>分成多个子问题，爬第n阶楼梯的<strong>方法</strong>数量，等于 2 部分之和</p> <p>​	<strong>爬上 n-1 阶楼梯的方法数量</strong></p> <p>​	<strong>爬上 n-2 阶楼梯的方法数量</strong></p> <div class="language- extra-class"><pre class="language-text"><code>动态规划的转移方程为：dp[i] = dp[i - 1] + dp[i - 2];
</code></pre></div><p>简单地使用动归求解（这里没必要使用递归这种时间复杂度较高的方法，除非用了记忆化递归~）</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>时间复杂度与空间复杂度都为O(N)</p> <ul><li>使用滚动数组（<strong>空间复杂度为1</strong>）实现动态规划（而不是使用<strong>空间复杂度为N</strong>的递归）
<ul><li>这也是官方题解的第一种方法（其他数学方法我退缩了XD）
<ul><li><img src="https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif" alt="fig1"></li></ul></li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 初始化dp[0] dp[1] dp[2]  for (let i = 2; i &lt;= n; i++) {    // 利用滚动数组达到O(1)空间复杂度的动归    p = q;    q = r;    r = p + q;  }  return r;};</span>
</code></pre></div><h1 id="_1-24-每日一题"><a href="#_1-24-每日一题" class="header-anchor">#</a> 1/24 每日一题</h1> <blockquote><p>1.字面量创建对象和 new 创建对象有什么区别，new 内部都实现了什么， 手写一个 new
2.<code>==</code>和<code>===</code>有什么区别
3.在 JS 中为什么 0.2+0.1&gt;0.3?
4.那为什么 0.2+0.3=0.5 呢?</p></blockquote> <h3 id="_1-字面量创建对象和-new-创建对象有什么区别"><a href="#_1-字面量创建对象和-new-创建对象有什么区别" class="header-anchor">#</a> 1.字面量创建对象和 new 创建对象有什么区别，</h3> <ul><li>字面量 <code>let obj = {}</code> ：
<ul><li>创建对象更简单</li> <li>方便阅读</li> <li>不需要作用域解析</li> <li>速度更快</li></ul></li></ul> <h3 id="_1-new-内部都实现了什么-手写一个-new"><a href="#_1-new-内部都实现了什么-手写一个-new" class="header-anchor">#</a> 1‘.new 内部都实现了什么， 手写一个 new</h3> <blockquote><p>红宝书权威解释</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f493f86148bf4a3c888e34b6f6fd79c1~tplv-k3u1fbpfcp-watermark.awebp?" alt="image.png"></p></blockquote> <p>更细致的内容之前我有总结过一篇，相当于是手写<code>new Object</code>吧——</p> <p><a href="https://juejin.cn/post/7012887169878458404" target="_blank" rel="noopener noreferrer">JS小知识 new关键字都做了什么？ - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>【1】在内存中创建一个新对象</li> <li>【2】使新对象的<code>__proto__</code>指向原函数的 prototype</li> <li>【3】改变 this 指向（指向新的 obj）</li> <li>【4】执行构造函数，给新对象添加属性</li> <li>【5】执行结果保存起来作为 result 并判断执行函数的结果是不是 null 或 Undefined
<ul><li>如果是则返回之前的新对象，</li> <li>如果不是则返回 result</li></ul></li></ul> <p>手写result</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 创建一个空对象     obj.__proto__ = fn.prototype// 使空对象的隐式原型指向原函数的显式原型    let result = fn.apply(obj, args)// this 指向 obj      return result instanceof Object ? result : obj// 返回创建的对象}</span>
</code></pre></div><h3 id="_2-和-有什么区别"><a href="#_2-和-有什么区别" class="header-anchor">#</a> 2.<code>==</code>和<code>===</code>有什么区别</h3> <ul><li><p>===是严格意义上的相等，会比较两边的数据类型和值大小 数据类型不同返回 false 数据类型相同，但值大小不同，返回 false</p></li> <li><p>==是非严格意义上的相等， 两边类型相同，比较大小 两边类型不同，根据下方的规则，再进一步进行比较。</p> <ul><li><p>Null == Undefined -&gt;true</p></li> <li><p><strong>String</strong> == Number -&gt;先将 String <strong>转为 Number</strong>，再比较大小</p></li> <li><p><strong>Boolean</strong> == Number -&gt;现将 Boolean <strong>转为 Number</strong>，再进行比较</p></li> <li><p><strong>Object</strong> == String，Number，Symbol -&gt; Object <strong>转化为原始类型</strong></p> <ul><li><h2 id="对象的强制类型转换流程总结"><a href="#对象的强制类型转换流程总结" class="header-anchor">#</a> 对象的强制类型转换流程总结</h2> <p>【1】调用valueOf()方法,是原始值类型就返回,不是就继续下一步</p> <p>【2】调用toString()方式,是原始值类型就返回,不是就继续下一步</p> <p>【3】调用Number,是原始值就返回,不是就报类型错误(也只有undefined大神会这样了😂</p> <p>作者：敲代码的小提琴手  链接：https://juejin.cn/post/7022837573059870727  来源：稀土掘金</p></li></ul></li></ul></li></ul> <blockquote><p>可以看看我之前总结的一篇隐式类型转换的文章</p> <p><a href="https://juejin.cn/post/7022837573059870727" target="_blank" rel="noopener noreferrer">由一道面试题引入的对JavaScript隐式转换的学习 - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>红宝书这里的内容</p> <p><img src="https://gitee.com/su-fangzhou/blog-image/raw/master/202201242353655.png" alt="image-20220124235359385"></p></blockquote></blockquote> <h3 id="_3-在-js-中为什么-0-2-0-1-0-3"><a href="#_3-在-js-中为什么-0-2-0-1-0-3" class="header-anchor">#</a> 3.在 JS 中为什么 0.2+0.1&gt;0.3?</h3> <p>因为<strong>在 JS 中，浮点数是使用 64 位固定长度来表示的</strong>，其中——</p> <ul><li>1 位表示符号位</li> <li>11 位 用来表示指数位</li> <li>剩下的 <strong>52 位尾数位</strong>。</li></ul> <p>由于只有 52 位表示尾数位。 而 0.1 转为二进制是一个无限循环数 0.0001100110011001100......(1100 循环)</p> <blockquote><p>小数的十进制转二进制方法：</p> <p>https://jingyan.baidu.com/article/425e69e6e93ca9be15fc1626.html 注意：小数的十进制转二进制的方法是和整数不一样的</p></blockquote> <p>由于只能存储 52 位尾数位，所以会出现<strong>精度缺失</strong>——</p> <p>比如：<strong>把0.1 存到内存中，再取出来转换成十进制就不是原来的 0.1 了</strong>，就变成了 0.100000000000000005551115123126</p> <p>而为什么 02+0.1 是因为</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 0.1 和 0.2 都转化成二进制后再进行运算 0.00011001100110011001100110011001100110011001100110011010(0.1) + 0.0011001100110011001100110011001100110011001100110011010(0.2) = 0.0100110011001100110011001100110011001100110011001100111 // 结果转成十进制正好是 0.30000000000000004</span>
</code></pre></div><h3 id="_4-那为什么-0-2-0-3-0-5-呢"><a href="#_4-那为什么-0-2-0-3-0-5-呢" class="header-anchor">#</a> 4.那为什么 0.2+0.3=0.5 呢?</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 0.2 和 0.3 都转化为二进制后再进行计算 0.001100110011001100110011001100110011001100110011001101 + 0.0100110011001100110011001100110011001100110011001101 = 0.10000000000000000000000000000000000000000000000000001 //尾数为大于 52 位 // 而实际取值只取 52 位尾数位，就变成了0.1000000000000000000000000000000000000000000000000000 </span>
</code></pre></div><p><code>0.2转化为二进制</code>+<code>0.3转换为二进制</code> 的结果恰巧前 52 位尾数都是 0，截取后恰好是 0.1000000000000000000000000000000000000000000000000000=<strong>0.1(2)</strong> 也就是 0.5(10)</p> <h3 id="_5-为什么-console-log-0-1-打印得到-0-1-呢"><a href="#_5-为什么-console-log-0-1-打印得到-0-1-呢" class="header-anchor">#</a> 5.为什么 console.log(0.1) 打印得到 0.1 呢</h3> <blockquote><p>那既然 0.1 不是 0.1 了，为什么 console.log(0.1) 打印得到 0.1 呢?</p></blockquote> <p>在 console.log 的时候会——</p> <ul><li>将二进制转换为十进制</li> <li>再将十进制转为字符串的形式</li></ul> <p>在转 换的过程中发生了取近似值，所以打印出来的是一个近似值的<strong>字符串</strong></p> <ul><li></li></ul> <h1 id="_1-25每日一题"><a href="#_1-25每日一题" class="header-anchor">#</a> 1.25每日一题</h1> <blockquote><p>1、三栏布局，有多少种？思路和代码
2、给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p> <p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
输入：digits = [1,2,3]
输出：[1,2,4]
3、css中定位有多少个值，每个值有什么特点
4、对BFC的理解，如何创建BFC</p></blockquote> <h2 id="_1、-三栏布局-有多少种-思路和代码"><a href="#_1、-三栏布局-有多少种-思路和代码" class="header-anchor">#</a> 1、==三栏布局==，有多少种？思路和代码</h2> <blockquote><p>重点是 圣杯布局 两翼布局</p></blockquote> <p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p> <ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的 margin 的值。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span> <span class="token punctuation">{</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><ul><li>利用 flex 布局，左右两栏设置固定大小，中间一栏设置为 flex:1。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span> <span class="token punctuation">{</span>  <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的 margin 值，注意这种方式**，中间一栏必须放到最后：**</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><ul><li>==圣杯布局==，利用<strong>浮动和负边距</strong>来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">padding-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">padding-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><ul><li>==双飞翼布局==，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 <strong>margin</strong> 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过<strong>浮动和外边距负值</strong>来实现的。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.left</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> tomato<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.right</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.wrapper</span> <span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.center</span> <span class="token punctuation">{</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><h2 id="_2、css中定位有多少个值-每个值有什么特点"><a href="#_2、css中定位有多少个值-每个值有什么特点" class="header-anchor">#</a> 2、css中定位有多少个值，每个值有什么特点</h2> <p>position 有以下属性值：</p> <table><thead><tr><th>属性值</th> <th>概述</th></tr></thead> <tbody><tr><td>absolute</td> <td>生成绝对定位的元素，相对于 static 定位以外的一个父元素进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。<strong>元素会被移除文档流</strong></td></tr> <tr><td>relative</td> <td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。<strong>元素会被移除文档流</strong></td></tr> <tr><td>fixed</td> <td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr> <tr><td>static</td> <td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr> <tr><td>inherit</td> <td>规定从父元素继承 position 属性的值</td></tr></tbody></table> <p>前面三者的定位方式如下：</p> <ul><li><strong>relative：<strong>元素的定位永远是</strong>相对于元素自身</strong>位置的，和其他元素没关系，也不会影响其他元素。</li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png#align=left&amp;display=inline&amp;height=105&amp;margin=%5Bobject%20Object%5D&amp;originHeight=105&amp;originWidth=448&amp;size=0&amp;status=done&amp;style=stroke&amp;width=447" alt="img"></p> <p><strong>fixed：<strong>元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它</strong>具有破坏性，会导致其他元素位置的变化</strong>(没脱离文档流还随心随遇地放置在某个位置！)。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png#align=left&amp;display=inline&amp;height=117&amp;margin=%5Bobject%20Object%5D&amp;originHeight=135&amp;originWidth=516&amp;size=0&amp;status=done&amp;style=stroke&amp;width=446" alt="img"></p> <p><strong>absolute：<strong>元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是</strong>浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位</strong>。如下两个图所示：</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png#align=left&amp;display=inline&amp;height=142&amp;margin=%5Bobject%20Object%5D&amp;originHeight=183&amp;originWidth=576&amp;size=0&amp;status=done&amp;style=stroke&amp;width=446" alt="img"></p> <blockquote><p>这里真是学习到了啊！</p></blockquote> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png#align=left&amp;display=inline&amp;height=118&amp;margin=%5Bobject%20Object%5D&amp;originHeight=137&amp;originWidth=516&amp;size=0&amp;status=done&amp;style=stroke&amp;width=446" alt="img"></p> <h2 id="_3、对bfc的理解-如何创建bfc"><a href="#_3、对bfc的理解-如何创建bfc" class="header-anchor">#</a> 3、对BFC的理解，如何创建BFC</h2> <ul><li>Block formatting contexts（块级格式化上下文）：首先 BFC 是一个<strong>独立的布局环境</strong>，BFC 中<strong>元素的布局</strong>是<strong>不受外界影响</strong>的。
<ul><li>本质上是指 <strong>盒子内部的元素不会影响外部元素</strong>的一个布局</li></ul></li> <li>如何创建一个 BFC
<ul><li><strong>float</strong> 的值不为 none</li> <li><strong>position</strong> 的值不为 static 或者 relative</li> <li><strong>display</strong> 的值为 table-cell、table-caption、inline-block、flex、inline-flex 中的一个</li> <li><strong>overflow</strong> 的值不为 visible</li></ul></li> <li>BFC 的使用场景
<ul><li>使用 BFC 来<strong>防止外边距折叠</strong></li> <li>使用 BFC 来包含浮动，<strong>解决容器高度塌陷</strong>的问题</li> <li>使用 BFC 来<strong>防止文字环绕</strong></li> <li>在多列布局中使用 BFC，解决最后一列被挤到下一行的问题</li></ul></li></ul> <h2 id="_4、给定一个由-整数-组成的-非空-数组所表示的非负整数-在该数的基础上加一。"><a href="#_4、给定一个由-整数-组成的-非空-数组所表示的非负整数-在该数的基础上加一。" class="header-anchor">#</a> 4、给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</h2> <blockquote><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
输入：digits = [1,2,3]
输出：[1,2,4]</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">plusOne</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">digits</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> n <span class="token operator">=</span> digits<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> digits<span class="token punctuation">;</span><span class="token comment">// 这一位没有进位就可以直接返回结果了~    }  }  digits.unshift(1);// 在最高位前面还要再进一位~  return digits;};</span>
</code></pre></div></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/frontend-knowledge-base/handbook/leetcode.html" class="prev">
            推荐刷题内容
          </a></span> <!----></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1、css篇-定位中-absolute-与-fixed-共同点与不同点" class="sidebar-link reco-side-_1、css篇-定位中-absolute-与-fixed-共同点与不同点" data-v-cb1513f6>1、CSS篇：定位中，absolute 与 fixed 共同点与不同点</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2、javascript篇-闭包的概念及特点" class="sidebar-link reco-side-_2、javascript篇-闭包的概念及特点" data-v-cb1513f6>2、JavaScript篇：闭包的概念及特点</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3、算法-说一下递归和迭代的区别是什么-各有什么优缺点" class="sidebar-link reco-side-_3、算法-说一下递归和迭代的区别是什么-各有什么优缺点" data-v-cb1513f6>3、算法：说一下递归和迭代的区别是什么，各有什么优缺点？</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_4、力扣101-对称二叉树" class="sidebar-link reco-side-_4、力扣101-对称二叉树" data-v-cb1513f6>4、力扣101.对称二叉树</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1-箭头函数与普通函数的区别" class="sidebar-link reco-side-_1-箭头函数与普通函数的区别" data-v-cb1513f6>1.箭头函数与普通函数的区别?</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2-this指向哪里" class="sidebar-link reco-side-_2-this指向哪里" data-v-cb1513f6>2.this指向哪里？</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3-扩展运算符的作用及使用场景" class="sidebar-link reco-side-_3-扩展运算符的作用及使用场景" data-v-cb1513f6>3.扩展运算符的作用及使用场景</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_4、217-存在重复元素" class="sidebar-link reco-side-_4、217-存在重复元素" data-v-cb1513f6>4、217. 存在重复元素</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1-讲一下强缓存和协商缓存的区别" class="sidebar-link reco-side-_1-讲一下强缓存和协商缓存的区别" data-v-cb1513f6>1.讲一下强缓存和协商缓存的区别</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2-如何解决跨越问题" class="sidebar-link reco-side-_2-如何解决跨越问题" data-v-cb1513f6>2.如何解决跨越问题</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3-对事件委托的理解以及其使用场景" class="sidebar-link reco-side-_3-对事件委托的理解以及其使用场景" data-v-cb1513f6>3.对事件委托的理解以及其使用场景</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_4-算法-最大数" class="sidebar-link reco-side-_4-算法-最大数" data-v-cb1513f6>4 算法，最大数</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1-cookie-sessionstorage-localstorage-的区别" class="sidebar-link reco-side-_1-cookie-sessionstorage-localstorage-的区别" data-v-cb1513f6>1.cookie &amp; sessionstorage &amp; localstorage 的区别</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2-浏览器的渲染过程" class="sidebar-link reco-side-_2-浏览器的渲染过程" data-v-cb1513f6>2.浏览器的渲染过程</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3-渐进增强和优雅降级" class="sidebar-link reco-side-_3-渐进增强和优雅降级" data-v-cb1513f6>3.渐进增强和优雅降级</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_4-手写斐波那契数列" class="sidebar-link reco-side-_4-手写斐波那契数列" data-v-cb1513f6>4.手写斐波那契数列</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1-字面量new出来的对象和object-create-null-创建出来的对象有什么区别" class="sidebar-link reco-side-_1-字面量new出来的对象和object-create-null-创建出来的对象有什么区别" data-v-cb1513f6>1.字面量new出来的对象和Object.create(null)创建出来的对象有什么区别？</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2-数据类型检测的方式都有哪些" class="sidebar-link reco-side-_2-数据类型检测的方式都有哪些" data-v-cb1513f6>2.数据类型检测的方式都有哪些?</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3-判断数组检测的方式都有哪些" class="sidebar-link reco-side-_3-判断数组检测的方式都有哪些" data-v-cb1513f6>3 判断数组检测的方式都有哪些?</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_4-new的具体操作过程" class="sidebar-link reco-side-_4-new的具体操作过程" data-v-cb1513f6>4. new的具体操作过程</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1-http-1-0-1-1-2-0-3-0对应的改进点-2-0实现多路复用的底层原理" class="sidebar-link reco-side-_1-http-1-0-1-1-2-0-3-0对应的改进点-2-0实现多路复用的底层原理" data-v-cb1513f6>1.HTTP: 1.0 1.1 2.0 3.0对应的改进点，2.0实现多路复用的底层原理？</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#http-1-0和-http-1-1-有以下区别" class="sidebar-link reco-side-http-1-0和-http-1-1-有以下区别" data-v-cb1513f6>HTTP 1.0和 HTTP 1.1 有以下区别：</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#http-1-1-和-http-2-0-的区别" class="sidebar-link reco-side-http-1-1-和-http-2-0-的区别" data-v-cb1513f6>HTTP 1.1 和 HTTP 2.0 的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#http3-0的特点" class="sidebar-link reco-side-http3-0的特点" data-v-cb1513f6>HTTP3.0的特点</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2-call-和-apply-bind" class="sidebar-link reco-side-_2-call-和-apply-bind" data-v-cb1513f6>2.call() 和 apply() bind()</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3-数据结构-map-和-set-的区别" class="sidebar-link reco-side-_3-数据结构-map-和-set-的区别" data-v-cb1513f6>3.数据结构: Map 和 Set 的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#map" class="sidebar-link reco-side-map" data-v-cb1513f6>Map</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#set" class="sidebar-link reco-side-set" data-v-cb1513f6>Set</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#二者区别" class="sidebar-link reco-side-二者区别" data-v-cb1513f6>二者区别</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1-javascript中对象继承的方式有哪些" class="sidebar-link reco-side-_1-javascript中对象继承的方式有哪些" data-v-cb1513f6>1. JavaScript中对象继承的方式有哪些？</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2-实现异步加载方法的关键字有哪些" class="sidebar-link reco-side-_2-实现异步加载方法的关键字有哪些" data-v-cb1513f6>2. 实现异步加载方法的关键字有哪些？</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3-什么是js的事件循环-事件循环机制是什么" class="sidebar-link reco-side-_3-什么是js的事件循环-事件循环机制是什么" data-v-cb1513f6>3. 什么是JS的事件循环 ， 事件循环机制是什么？</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_4-leetcode-20-有效的括号" class="sidebar-link reco-side-_4-leetcode-20-有效的括号" data-v-cb1513f6>4 leetcode 20 有效的括号</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1-let、const、var区别" class="sidebar-link reco-side-_1-let、const、var区别" data-v-cb1513f6>1. let、const、var区别</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2-数组去重-的方法有哪些" class="sidebar-link reco-side-_2-数组去重-的方法有哪些" data-v-cb1513f6>2. ==数组去重==的方法有哪些？</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3-vue双向绑定的原理" class="sidebar-link reco-side-_3-vue双向绑定的原理" data-v-cb1513f6>3. vue双向绑定的原理</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_4-70-爬楼梯-力扣-leetcode-leetcode-cn-com" class="sidebar-link reco-side-_4-70-爬楼梯-力扣-leetcode-leetcode-cn-com" data-v-cb1513f6>4.70. 爬楼梯 - 力扣（LeetCode） (leetcode-cn.com)</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1-字面量创建对象和-new-创建对象有什么区别" class="sidebar-link reco-side-_1-字面量创建对象和-new-创建对象有什么区别" data-v-cb1513f6>1.字面量创建对象和 new 创建对象有什么区别，</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1-new-内部都实现了什么-手写一个-new" class="sidebar-link reco-side-_1-new-内部都实现了什么-手写一个-new" data-v-cb1513f6>1‘.new 内部都实现了什么， 手写一个 new</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2-和-有什么区别" class="sidebar-link reco-side-_2-和-有什么区别" data-v-cb1513f6>2.==和===有什么区别</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#对象的强制类型转换流程总结" class="sidebar-link reco-side-对象的强制类型转换流程总结" data-v-cb1513f6>对象的强制类型转换流程总结</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3-在-js-中为什么-0-2-0-1-0-3" class="sidebar-link reco-side-_3-在-js-中为什么-0-2-0-1-0-3" data-v-cb1513f6>3.在 JS 中为什么 0.2+0.1&gt;0.3?</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_4-那为什么-0-2-0-3-0-5-呢" class="sidebar-link reco-side-_4-那为什么-0-2-0-3-0-5-呢" data-v-cb1513f6>4.那为什么 0.2+0.3=0.5 呢?</a></li><li class="level-3" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_5-为什么-console-log-0-1-打印得到-0-1-呢" class="sidebar-link reco-side-_5-为什么-console-log-0-1-打印得到-0-1-呢" data-v-cb1513f6>5.为什么 console.log(0.1) 打印得到 0.1 呢</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_1、-三栏布局-有多少种-思路和代码" class="sidebar-link reco-side-_1、-三栏布局-有多少种-思路和代码" data-v-cb1513f6>1、==三栏布局==，有多少种？思路和代码</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_2、css中定位有多少个值-每个值有什么特点" class="sidebar-link reco-side-_2、css中定位有多少个值-每个值有什么特点" data-v-cb1513f6>2、css中定位有多少个值，每个值有什么特点</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_3、对bfc的理解-如何创建bfc" class="sidebar-link reco-side-_3、对bfc的理解-如何创建bfc" data-v-cb1513f6>3、对BFC的理解，如何创建BFC</a></li><li class="level-2" data-v-cb1513f6><a href="/frontend-knowledge-base/study-everyday/22-1-study.html#_4、给定一个由-整数-组成的-非空-数组所表示的非负整数-在该数的基础上加一。" class="sidebar-link reco-side-_4、给定一个由-整数-组成的-非空-数组所表示的非负整数-在该数的基础上加一。" data-v-cb1513f6>4、给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/frontend-knowledge-base/assets/js/app.173ea465.js" defer></script><script src="/frontend-knowledge-base/assets/js/3.ceeb50c6.js" defer></script><script src="/frontend-knowledge-base/assets/js/1.8451d83f.js" defer></script><script src="/frontend-knowledge-base/assets/js/15.71d1729f.js" defer></script>
  </body>
</html>
